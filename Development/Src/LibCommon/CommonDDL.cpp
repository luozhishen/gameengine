////////////////////////////////////////////////
// THIS FILE IS AUTOGENERATED. DO NOT MODIFY! //
////////////////////////////////////////////////

#include "CommonDDL.h"

namespace DDL
{
	template<>
	bool BufferReader::Read<A_CONTENT_OBJECT>(A_CONTENT_OBJECT& Value)
	{
		if(!Read<A_UUID>(Value.uuid)) return false;
		if(!ReadString<100>(Value.name)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<A_CONTENT_OBJECT>(const A_CONTENT_OBJECT& Value)
	{
		if(!Write<A_UUID>(Value.uuid)) return false;
		if(!WriteString<100>(Value.name)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_A_CONTENT_OBJECT_fieldinfo[] =
	{
		{TYPE_UUID, "uuid", 0|FLAG_READONLY, ATLAS_OFFSETOF(A_CONTENT_OBJECT, uuid), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
		{TYPE_STRING, "name", 0|FLAG_NOTNULL, ATLAS_OFFSETOF(A_CONTENT_OBJECT, name), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
	};
	STRUCT_INFO _rfl_struct_A_CONTENT_OBJECT_info = { NULL, "A_CONTENT_OBJECT", sizeof(A_CONTENT_OBJECT), 2, _struct_A_CONTENT_OBJECT_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<A_CONTENT_OBJECT>()
	{
		return &_rfl_struct_A_CONTENT_OBJECT_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<A_LIVE_OBJECT>(A_LIVE_OBJECT& Value)
	{
		if(!Read<A_UUID>(Value.uuid)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<A_LIVE_OBJECT>(const A_LIVE_OBJECT& Value)
	{
		if(!Write<A_UUID>(Value.uuid)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_A_LIVE_OBJECT_fieldinfo[] =
	{
		{TYPE_UUID, "uuid", 0, ATLAS_OFFSETOF(A_LIVE_OBJECT, uuid), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
	};
	STRUCT_INFO _rfl_struct_A_LIVE_OBJECT_info = { NULL, "A_LIVE_OBJECT", sizeof(A_LIVE_OBJECT), 1, _struct_A_LIVE_OBJECT_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<A_LIVE_OBJECT>()
	{
		return &_rfl_struct_A_LIVE_OBJECT_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<A_SYNC_OBJECT>(A_SYNC_OBJECT& Value)
	{
		return true;
	}
	template<>
	bool BufferWriter::Write<A_SYNC_OBJECT>(const A_SYNC_OBJECT& Value)
	{
		return true;
	}
}

namespace DDLReflect
{
	STRUCT_INFO _rfl_struct_A_SYNC_OBJECT_info = { NULL, "A_SYNC_OBJECT", sizeof(A_SYNC_OBJECT), 0, NULL };
	template<>
	const STRUCT_INFO* GetStruct<A_SYNC_OBJECT>()
	{
		return &_rfl_struct_A_SYNC_OBJECT_info;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _class_SyncObjectProtocol_fieldinfos[] = 
	{
		// 0 CreateDomain
		{TYPE_U16, "domain", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 1 DeleteDomain
		{TYPE_U16, "domain", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 2 CreateObject
		{TYPE_U16, "domain", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "id", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U16, "index", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U16, "type", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "len", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U8|TYPE_ARRAY, "data", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 3 UpdateObject
		{TYPE_U16, "domain", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "id", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U16, "index", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U16, "type", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "len", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U8|TYPE_ARRAY, "data", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 4 DeleteObject
		{TYPE_U32, "domain", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "id", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U16, "index", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
	};
	static FUNCTION_INFO _class_SyncObjectProtocol_funcinfos[] = 
	{
		{"CreateDomain", 1, _class_SyncObjectProtocol_fieldinfos+0},
		{"DeleteDomain", 1, _class_SyncObjectProtocol_fieldinfos+1},
		{"CreateObject", 6, _class_SyncObjectProtocol_fieldinfos+2},
		{"UpdateObject", 6, _class_SyncObjectProtocol_fieldinfos+8},
		{"DeleteObject", 3, _class_SyncObjectProtocol_fieldinfos+14},
	};
	static CLASS_INFO _class_SyncObjectProtocol_info = { 0, "SyncObjectProtocol", 5, _class_SyncObjectProtocol_funcinfos };
	template<>
	const CLASS_INFO* GetClass<SyncObjectProtocol>()
	{
		return &_class_SyncObjectProtocol_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ITEM>(SG_ITEM& Value)
	{
		if(!Read<A_UUID>(Value.fref)) return false;
		if(!Read<A_UUID>(Value.fuuid)) return false;
		if(!Read<_U8>(Value.u8)) return false;
		if(!Read<_U16>(Value.u16)) return false;
		if(!Read<_U32>(Value.u32)) return false;
		if(!Read<_U64>(Value.u64)) return false;
		if(!Read<_S8>(Value.s8)) return false;
		if(!Read<_S16>(Value.s16)) return false;
		if(!Read<_S32>(Value.s32)) return false;
		if(!Read<_S64>(Value.s64)) return false;
		if(!Read<_F32>(Value.f32)) return false;
		if(!Read<_F64>(Value.f64)) return false;
		if(!ReadString<100>(Value.str)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ITEM>(const SG_ITEM& Value)
	{
		if(!Write<A_UUID>(Value.fref)) return false;
		if(!Write<A_UUID>(Value.fuuid)) return false;
		if(!Write<_U8>(Value.u8)) return false;
		if(!Write<_U16>(Value.u16)) return false;
		if(!Write<_U32>(Value.u32)) return false;
		if(!Write<_U64>(Value.u64)) return false;
		if(!Write<_S8>(Value.s8)) return false;
		if(!Write<_S16>(Value.s16)) return false;
		if(!Write<_S32>(Value.s32)) return false;
		if(!Write<_S64>(Value.s64)) return false;
		if(!Write<_F32>(Value.f32)) return false;
		if(!Write<_F64>(Value.f64)) return false;
		if(!WriteString<100>(Value.str)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ITEM_fieldinfo[] =
	{
		{TYPE_UUID_REF, "fref", 0, ATLAS_OFFSETOF(SG_ITEM, fref), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), "SG_ENEMY_CONFIG"},
		{TYPE_UUID, "fuuid", 0, ATLAS_OFFSETOF(SG_ITEM, fuuid), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
		{TYPE_U8, "u8", 0, ATLAS_OFFSETOF(SG_ITEM, u8), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U8), NULL},
		{TYPE_U16, "u16", 0, ATLAS_OFFSETOF(SG_ITEM, u16), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_U32, "u32", 0, ATLAS_OFFSETOF(SG_ITEM, u32), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U64, "u64", 0, ATLAS_OFFSETOF(SG_ITEM, u64), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U64), NULL},
		{TYPE_S8, "s8", 0, ATLAS_OFFSETOF(SG_ITEM, s8), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S8), NULL},
		{TYPE_S16, "s16", 0, ATLAS_OFFSETOF(SG_ITEM, s16), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S16), NULL},
		{TYPE_S32, "s32", 0, ATLAS_OFFSETOF(SG_ITEM, s32), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S64, "s64", 0, ATLAS_OFFSETOF(SG_ITEM, s64), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S64), NULL},
		{TYPE_F32, "f32", 0, ATLAS_OFFSETOF(SG_ITEM, f32), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F64, "f64", 0, ATLAS_OFFSETOF(SG_ITEM, f64), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F64), NULL},
		{TYPE_STRING, "str", 0, ATLAS_OFFSETOF(SG_ITEM, str), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ITEM_info = { NULL, "SG_ITEM", sizeof(SG_ITEM), 13, _struct_SG_ITEM_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ITEM>()
	{
		return &_rfl_struct_SG_ITEM_info;
	}
}

