////////////////////////////////////////////////
// THIS FILE IS AUTOGENERATED. DO NOT MODIFY! //
////////////////////////////////////////////////

#ifndef __CARDGAMEDDL_DDL_CODEGEN__
#define __CARDGAMEDDL_DDL_CODEGEN__

#include <ZionDefines.h>
#include <ZionSTL.h>
#include <ZionUUID.h>
#include <DDL.h>
#include <DDLProxy.h>
#include <DDLStub.h>
#include <DDLReflect.h>

#pragma pack(push)
#pragma pack(4)

#include "../../LibCommon/CommonDDL.h"

struct CARD_CONFIG : A_CONTENT_OBJECT
{
	_U32 iii;
};

namespace DDL
{
	template<>
	bool BufferReader::Read<CARD_CONFIG>(CARD_CONFIG& Value);
	template<>
	bool BufferWriter::Write<CARD_CONFIG>(const CARD_CONFIG& Value);
}

namespace DDLReflect
{
	template<>
	const STRUCT_INFO* GetStruct<CARD_CONFIG>();
	extern STRUCT_INFO _rfl_struct_CARD_CONFIG_info;
}

struct CARD_INVITATION : A_CONTENT_OBJECT
{
	_U32 iii;
};

namespace DDL
{
	template<>
	bool BufferReader::Read<CARD_INVITATION>(CARD_INVITATION& Value);
	template<>
	bool BufferWriter::Write<CARD_INVITATION>(const CARD_INVITATION& Value);
}

namespace DDLReflect
{
	template<>
	const STRUCT_INFO* GetStruct<CARD_INVITATION>();
	extern STRUCT_INFO _rfl_struct_CARD_INVITATION_info;
}

class CARDGAME_C2S;

class CARDGAME_S2C;

namespace DDLStub
{

	template<typename CALLER, typename CLASS>
	class CARDGAME_C2S : public DDLStub<CALLER, CLASS>
	{
	public:
		CARDGAME_C2S(CLASS* Class) : DDLStub<CALLER, CLASS>(Class)
		{
		}

		virtual bool Dispatcher(CALLER* Caller, _U16 fid, DDL::BufferReader& Buf)
		{
			if(fid==0)
			{


				// call implement
				DDLStub<CALLER, CLASS>::GetClass()->Ping(Caller);
				return true;
			}
			return false;
		}
	};

}

namespace DDLProxy
{

	template<typename CLIENT, typename BUFFER>
	class CARDGAME_C2S : public DDLProxy<CLIENT, BUFFER>
	{
	public:
		CARDGAME_C2S(CLIENT* Client) : DDLProxy<CLIENT, BUFFER>(Client, DDLReflect::GetClassID<typename ::CARDGAME_C2S>())
		{
		}

		static CARDGAME_C2S<CLIENT, BUFFER> Get(CLIENT* Client)
		{
			CARDGAME_C2S<CLIENT, BUFFER> Proxy(Client);
			return Proxy;
		}

		bool Ping()
		{
			BUFFER Buf;

			// send
			return this->GetClient()->Send(this->GetClassID(), 0, Buf);
		}
	};

}

namespace DDLReflect
{
	template<>
	const CLASS_INFO* GetClass<CARDGAME_C2S>();
}

namespace DDLStub
{

	template<typename CALLER, typename CLASS>
	class CARDGAME_S2C : public DDLStub<CALLER, CLASS>
	{
	public:
		CARDGAME_S2C(CLASS* Class) : DDLStub<CALLER, CLASS>(Class)
		{
		}

		virtual bool Dispatcher(CALLER* Caller, _U16 fid, DDL::BufferReader& Buf)
		{
			if(fid==0)
			{


				// call implement
				DDLStub<CALLER, CLASS>::GetClass()->Pong(Caller);
				return true;
			}
			return false;
		}
	};

}

namespace DDLProxy
{

	template<typename CLIENT, typename BUFFER>
	class CARDGAME_S2C : public DDLProxy<CLIENT, BUFFER>
	{
	public:
		CARDGAME_S2C(CLIENT* Client) : DDLProxy<CLIENT, BUFFER>(Client, DDLReflect::GetClassID<typename ::CARDGAME_S2C>())
		{
		}

		static CARDGAME_S2C<CLIENT, BUFFER> Get(CLIENT* Client)
		{
			CARDGAME_S2C<CLIENT, BUFFER> Proxy(Client);
			return Proxy;
		}

		bool Pong()
		{
			BUFFER Buf;

			// send
			return this->GetClient()->Send(this->GetClassID(), 0, Buf);
		}
	};

}

namespace DDLReflect
{
	template<>
	const CLASS_INFO* GetClass<CARDGAME_S2C>();
}


#pragma pack(pop)

#endif
