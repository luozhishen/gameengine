////////////////////////////////////////////////
// THIS FILE IS AUTOGENERATED. DO NOT MODIFY! //
////////////////////////////////////////////////

#ifndef __COMMONDDL_DDL_CODEGEN__
#define __COMMONDDL_DDL_CODEGEN__

#pragma pack(push)
#pragma pack(4)

struct A_CONTENT_OBJECT
{
	A_UUID _uuid;
	DDL::String<100> _name;
};

namespace DDL
{
	template<>
	bool BufferReader::Read<A_CONTENT_OBJECT>(A_CONTENT_OBJECT& Value);
	template<>
	bool BufferWriter::Write<A_CONTENT_OBJECT>(const A_CONTENT_OBJECT& Value);
}

namespace DDLReflect
{
	template<>
	const STRUCT_INFO* GetStruct<A_CONTENT_OBJECT>();
	extern STRUCT_INFO _rfl_struct_A_CONTENT_OBJECT_info;
}

struct A_LIVE_OBJECT
{
	A_UUID _uuid;
};

namespace DDL
{
	template<>
	bool BufferReader::Read<A_LIVE_OBJECT>(A_LIVE_OBJECT& Value);
	template<>
	bool BufferWriter::Write<A_LIVE_OBJECT>(const A_LIVE_OBJECT& Value);
}

namespace DDLReflect
{
	template<>
	const STRUCT_INFO* GetStruct<A_LIVE_OBJECT>();
	extern STRUCT_INFO _rfl_struct_A_LIVE_OBJECT_info;
}

class DATASYNC_C2S;

class DATASYNC_S2C;

namespace DDLStub
{

	template<typename CLASS>
	class DATASYNC_C2S : public DDLStub<CLASS>
	{
	public:
		DATASYNC_C2S(CLASS* Class) : DDLStub<CLASS>(Class)
		{
		}

		virtual const DDLReflect::CLASS_INFO* GetClassInfo()
		{
			return DDLReflect::GetClass<DATASYNC_C2S>();
		}
		
		virtual bool Dispatcher(_U16 fid, DDL::BufferReader& Buf)
		{
			if(fid==0)
			{
				_U32 __length;
				char* _prefix_type;
				char* _prefix_data;

				// <string> <type> <> <>;
				if(!Buf.Read(__length)) return false;
				_prefix_type = (char*)alloca(sizeof(_prefix_type[0])*(__length+1));
				if(!_prefix_type) return false;
				if(!Buf.ReadBuffer(_prefix_type, (unsigned int)sizeof(_prefix_type[0])*__length)) return false;
				_prefix_type[__length] = '\0';
				// <string> <data> <> <>;
				if(!Buf.Read(__length)) return false;
				_prefix_data = (char*)alloca(sizeof(_prefix_data[0])*(__length+1));
				if(!_prefix_data) return false;
				if(!Buf.ReadBuffer(_prefix_data, (unsigned int)sizeof(_prefix_data[0])*__length)) return false;
				_prefix_data[__length] = '\0';

				// call implement
				DDLStub<CLASS>::GetClass()->CreateObject(_prefix_type, _prefix_data);
				return true;
			}
			if(fid==1)
			{
				A_UUID _prefix__uuid;

				// <A_UUID> <_uuid> <> <>;
				if(!Buf.Read(_prefix__uuid)) return false;

				// call implement
				DDLStub<CLASS>::GetClass()->RemoveObject(_prefix__uuid);
				return true;
			}
			if(fid==2)
			{
				_U32 __length;
				A_UUID _prefix__uuid;
				char* _prefix_data;

				// <A_UUID> <_uuid> <> <>;
				if(!Buf.Read(_prefix__uuid)) return false;
				// <string> <data> <> <>;
				if(!Buf.Read(__length)) return false;
				_prefix_data = (char*)alloca(sizeof(_prefix_data[0])*(__length+1));
				if(!_prefix_data) return false;
				if(!Buf.ReadBuffer(_prefix_data, (unsigned int)sizeof(_prefix_data[0])*__length)) return false;
				_prefix_data[__length] = '\0';

				// call implement
				DDLStub<CLASS>::GetClass()->UpdateObject(_prefix__uuid, _prefix_data);
				return true;
			}
			return false;
		}
	};

}

namespace DDLProxy
{

	template<typename CLIENT, typename BUFFER>
	class DATASYNC_C2S : public DDLProxy<CLIENT, BUFFER>
	{
	public:
		DATASYNC_C2S(CLIENT* Client) : DDLProxy<CLIENT, BUFFER>(Client, DDLReflect::GetClassID<typename ::DATASYNC_C2S>())
		{
		}

		static DATASYNC_C2S<CLIENT, BUFFER> Get(CLIENT* Client)
		{
			DATASYNC_C2S<CLIENT, BUFFER> Proxy(Client);
			return Proxy;
		}

		bool CreateObject(const char* type, const char* data)
		{
			BUFFER Buf;
			_U32 __length;
			// <string> <type> <> <>
			__length = DDL::StringLength(type);
			if(!Buf.Write(__length)) return false;
			if(!Buf.WriteData(type, (unsigned int)sizeof(type[0])*__length)) return false;
			// <string> <data> <> <>
			__length = DDL::StringLength(data);
			if(!Buf.Write(__length)) return false;
			if(!Buf.WriteData(data, (unsigned int)sizeof(data[0])*__length)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 0, Buf);
		}

		bool RemoveObject(const A_UUID& _uuid)
		{
			BUFFER Buf;
			// <A_UUID> <_uuid> <> <>
			if(!Buf.Write(_uuid)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 1, Buf);
		}

		bool UpdateObject(const A_UUID& _uuid, const char* data)
		{
			BUFFER Buf;
			_U32 __length;
			// <A_UUID> <_uuid> <> <>
			if(!Buf.Write(_uuid)) return false;
			// <string> <data> <> <>
			__length = DDL::StringLength(data);
			if(!Buf.Write(__length)) return false;
			if(!Buf.WriteData(data, (unsigned int)sizeof(data[0])*__length)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 2, Buf);
		}
	};

}

namespace DDLReflect
{
	template<>
	const CLASS_INFO* GetClass<DATASYNC_C2S>();
}

namespace DDLStub
{

	template<typename CLASS>
	class DATASYNC_S2C : public DDLStub<CLASS>
	{
	public:
		DATASYNC_S2C(CLASS* Class) : DDLStub<CLASS>(Class)
		{
		}

		virtual const DDLReflect::CLASS_INFO* GetClassInfo()
		{
			return DDLReflect::GetClass<DATASYNC_S2C>();
		}
		
		virtual bool Dispatcher(_U16 fid, DDL::BufferReader& Buf)
		{
			if(fid==0)
			{
				_U16 _prefix_mode;

				// <_U16> <mode> <> <>;
				if(!Buf.Read(_prefix_mode)) return false;

				// call implement
				DDLStub<CLASS>::GetClass()->SyncStart(_prefix_mode);
				return true;
			}
			if(fid==1)
			{


				// call implement
				DDLStub<CLASS>::GetClass()->SyncReady();
				return true;
			}
			if(fid==2)
			{


				// call implement
				DDLStub<CLASS>::GetClass()->SyncDisable();
				return true;
			}
			if(fid==3)
			{
				A_UUID _prefix__uuid;

				// <A_UUID> <_uuid> <> <>;
				if(!Buf.Read(_prefix__uuid)) return false;

				// call implement
				DDLStub<CLASS>::GetClass()->CreateObjectDone(_prefix__uuid);
				return true;
			}
			if(fid==4)
			{
				_U32 __length;
				A_UUID _prefix__uuid;
				char* _prefix_type;
				char* _prefix_data;

				// <A_UUID> <_uuid> <> <>;
				if(!Buf.Read(_prefix__uuid)) return false;
				// <string> <type> <> <>;
				if(!Buf.Read(__length)) return false;
				_prefix_type = (char*)alloca(sizeof(_prefix_type[0])*(__length+1));
				if(!_prefix_type) return false;
				if(!Buf.ReadBuffer(_prefix_type, (unsigned int)sizeof(_prefix_type[0])*__length)) return false;
				_prefix_type[__length] = '\0';
				// <string> <data> <> <>;
				if(!Buf.Read(__length)) return false;
				_prefix_data = (char*)alloca(sizeof(_prefix_data[0])*(__length+1));
				if(!_prefix_data) return false;
				if(!Buf.ReadBuffer(_prefix_data, (unsigned int)sizeof(_prefix_data[0])*__length)) return false;
				_prefix_data[__length] = '\0';

				// call implement
				DDLStub<CLASS>::GetClass()->CreateObject(_prefix__uuid, _prefix_type, _prefix_data);
				return true;
			}
			if(fid==5)
			{
				A_UUID _prefix__uuid;

				// <A_UUID> <_uuid> <> <>;
				if(!Buf.Read(_prefix__uuid)) return false;

				// call implement
				DDLStub<CLASS>::GetClass()->RemoveObject(_prefix__uuid);
				return true;
			}
			if(fid==6)
			{
				_U32 __length;
				A_UUID _prefix__uuid;
				char* _prefix_data;

				// <A_UUID> <_uuid> <> <>;
				if(!Buf.Read(_prefix__uuid)) return false;
				// <string> <data> <> <>;
				if(!Buf.Read(__length)) return false;
				_prefix_data = (char*)alloca(sizeof(_prefix_data[0])*(__length+1));
				if(!_prefix_data) return false;
				if(!Buf.ReadBuffer(_prefix_data, (unsigned int)sizeof(_prefix_data[0])*__length)) return false;
				_prefix_data[__length] = '\0';

				// call implement
				DDLStub<CLASS>::GetClass()->UpdateObject(_prefix__uuid, _prefix_data);
				return true;
			}
			return false;
		}
	};

}

namespace DDLProxy
{

	template<typename CLIENT, typename BUFFER>
	class DATASYNC_S2C : public DDLProxy<CLIENT, BUFFER>
	{
	public:
		DATASYNC_S2C(CLIENT* Client) : DDLProxy<CLIENT, BUFFER>(Client, DDLReflect::GetClassID<typename ::DATASYNC_S2C>())
		{
		}

		static DATASYNC_S2C<CLIENT, BUFFER> Get(CLIENT* Client)
		{
			DATASYNC_S2C<CLIENT, BUFFER> Proxy(Client);
			return Proxy;
		}

		bool SyncStart(_U16 mode)
		{
			BUFFER Buf;
			// <_U16> <mode> <> <>
			if(!Buf.Write(mode)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 0, Buf);
		}

		bool SyncReady()
		{
			BUFFER Buf;

			// send
			return this->GetClient()->Send(this->GetClassID(), 1, Buf);
		}

		bool SyncDisable()
		{
			BUFFER Buf;

			// send
			return this->GetClient()->Send(this->GetClassID(), 2, Buf);
		}

		bool CreateObjectDone(const A_UUID& _uuid)
		{
			BUFFER Buf;
			// <A_UUID> <_uuid> <> <>
			if(!Buf.Write(_uuid)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 3, Buf);
		}

		bool CreateObject(const A_UUID& _uuid, const char* type, const char* data)
		{
			BUFFER Buf;
			_U32 __length;
			// <A_UUID> <_uuid> <> <>
			if(!Buf.Write(_uuid)) return false;
			// <string> <type> <> <>
			__length = DDL::StringLength(type);
			if(!Buf.Write(__length)) return false;
			if(!Buf.WriteData(type, (unsigned int)sizeof(type[0])*__length)) return false;
			// <string> <data> <> <>
			__length = DDL::StringLength(data);
			if(!Buf.Write(__length)) return false;
			if(!Buf.WriteData(data, (unsigned int)sizeof(data[0])*__length)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 4, Buf);
		}

		bool RemoveObject(const A_UUID& _uuid)
		{
			BUFFER Buf;
			// <A_UUID> <_uuid> <> <>
			if(!Buf.Write(_uuid)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 5, Buf);
		}

		bool UpdateObject(const A_UUID& _uuid, const char* data)
		{
			BUFFER Buf;
			_U32 __length;
			// <A_UUID> <_uuid> <> <>
			if(!Buf.Write(_uuid)) return false;
			// <string> <data> <> <>
			__length = DDL::StringLength(data);
			if(!Buf.Write(__length)) return false;
			if(!Buf.WriteData(data, (unsigned int)sizeof(data[0])*__length)) return false;

			// send
			return this->GetClient()->Send(this->GetClassID(), 6, Buf);
		}
	};

}

namespace DDLReflect
{
	template<>
	const CLASS_INFO* GetClass<DATASYNC_S2C>();
}


#pragma pack(pop)

#endif
