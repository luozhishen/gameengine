////////////////////////////////////////////////
// THIS FILE IS AUTOGENERATED. DO NOT MODIFY! //
////////////////////////////////////////////////

#include "SGGameDDL.h"

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ATTR_MOD_CONFIG>(SG_ATTR_MOD_CONFIG& Value)
	{
		if(!Read<_F32>(Value.MOD_HPAddition)) return false;
		if(!Read<_F32>(Value.MOD_HPPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraHP)) return false;
		if(!Read<_F32>(Value.MOD_ATKAddition)) return false;
		if(!Read<_F32>(Value.MOD_ATKPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraATK)) return false;
		if(!Read<_F32>(Value.MOD_DEFAddition)) return false;
		if(!Read<_F32>(Value.MOD_DEFPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraDEF)) return false;
		if(!Read<_F32>(Value.MOD_HITAddition)) return false;
		if(!Read<_F32>(Value.MOD_EvasionAddition)) return false;
		if(!Read<_F32>(Value.MOD_CRITAddition)) return false;
		if(!Read<_F32>(Value.MOD_SPAddition)) return false;
		if(!Read<_F32>(Value.MOD_WSAddition)) return false;
		if(!Read<_F32>(Value.MOD_WSPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraWS)) return false;
		if(!Read<_F32>(Value.MOD_STRAddition)) return false;
		if(!Read<_F32>(Value.MOD_STRPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraSTR)) return false;
		if(!Read<_F32>(Value.MOD_INTAddition)) return false;
		if(!Read<_F32>(Value.MOD_INTPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraINT)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ATTR_MOD_CONFIG>(const SG_ATTR_MOD_CONFIG& Value)
	{
		if(!Write<_F32>(Value.MOD_HPAddition)) return false;
		if(!Write<_F32>(Value.MOD_HPPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraHP)) return false;
		if(!Write<_F32>(Value.MOD_ATKAddition)) return false;
		if(!Write<_F32>(Value.MOD_ATKPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraATK)) return false;
		if(!Write<_F32>(Value.MOD_DEFAddition)) return false;
		if(!Write<_F32>(Value.MOD_DEFPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraDEF)) return false;
		if(!Write<_F32>(Value.MOD_HITAddition)) return false;
		if(!Write<_F32>(Value.MOD_EvasionAddition)) return false;
		if(!Write<_F32>(Value.MOD_CRITAddition)) return false;
		if(!Write<_F32>(Value.MOD_SPAddition)) return false;
		if(!Write<_F32>(Value.MOD_WSAddition)) return false;
		if(!Write<_F32>(Value.MOD_WSPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraWS)) return false;
		if(!Write<_F32>(Value.MOD_STRAddition)) return false;
		if(!Write<_F32>(Value.MOD_STRPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraSTR)) return false;
		if(!Write<_F32>(Value.MOD_INTAddition)) return false;
		if(!Write<_F32>(Value.MOD_INTPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraINT)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ATTR_MOD_CONFIG_fieldinfo[] =
	{
		{TYPE_F32, "MOD_HPAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_HPAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_HPPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_HPPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraHP", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraHP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ATKAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ATKAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ATKPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ATKPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraATK", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraATK), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_DEFAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_DEFAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_DEFPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_DEFPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraDEF", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraDEF), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_HITAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_HITAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_EvasionAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_EvasionAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_CRITAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_CRITAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_SPAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_SPAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_WSAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_WSAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_WSPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_WSPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraWS", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraWS), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_STRAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_STRAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_STRPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_STRPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraSTR", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraSTR), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_INTAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_INTAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_INTPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_INTPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraINT", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraINT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ATTR_MOD_CONFIG_info = { NULL, "SG_ATTR_MOD_CONFIG", sizeof(SG_ATTR_MOD_CONFIG), 22, _struct_SG_ATTR_MOD_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ATTR_MOD_CONFIG>()
	{
		return &_rfl_struct_SG_ATTR_MOD_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ATTR_BASE_CONFIG>(SG_ATTR_BASE_CONFIG& Value)
	{
		if(!Read<_F32>(Value.Base_HP)) return false;
		if(!Read<_F32>(Value.Base_ATK)) return false;
		if(!Read<_F32>(Value.Base_DEF)) return false;
		if(!Read<_F32>(Value.Base_HIT)) return false;
		if(!Read<_F32>(Value.Base_Evasion)) return false;
		if(!Read<_F32>(Value.Base_CRIT)) return false;
		if(!Read<_F32>(Value.Base_SP)) return false;
		if(!Read<_F32>(Value.Base_WS)) return false;
		if(!Read<_F32>(Value.Base_STR)) return false;
		if(!Read<_F32>(Value.Base_INT)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ATTR_BASE_CONFIG>(const SG_ATTR_BASE_CONFIG& Value)
	{
		if(!Write<_F32>(Value.Base_HP)) return false;
		if(!Write<_F32>(Value.Base_ATK)) return false;
		if(!Write<_F32>(Value.Base_DEF)) return false;
		if(!Write<_F32>(Value.Base_HIT)) return false;
		if(!Write<_F32>(Value.Base_Evasion)) return false;
		if(!Write<_F32>(Value.Base_CRIT)) return false;
		if(!Write<_F32>(Value.Base_SP)) return false;
		if(!Write<_F32>(Value.Base_WS)) return false;
		if(!Write<_F32>(Value.Base_STR)) return false;
		if(!Write<_F32>(Value.Base_INT)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ATTR_BASE_CONFIG_fieldinfo[] =
	{
		{TYPE_F32, "Base_HP", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_HP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_ATK", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_ATK), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_DEF", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_DEF), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_HIT", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_HIT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_Evasion", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_Evasion), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_CRIT", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_CRIT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_SP", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_SP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_WS", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_WS), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_STR", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_STR), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_INT", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_INT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ATTR_BASE_CONFIG_info = { NULL, "SG_ATTR_BASE_CONFIG", sizeof(SG_ATTR_BASE_CONFIG), 10, _struct_SG_ATTR_BASE_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ATTR_BASE_CONFIG>()
	{
		return &_rfl_struct_SG_ATTR_BASE_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_PAWN_CONFIG>(SG_PAWN_CONFIG& Value)
	{
		if(!Read<SG_ATTR_BASE_CONFIG>(Value.BaseConfig)) return false;
		if(!Read<SG_ATTR_MOD_CONFIG>(Value.SigmaConfig)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_PAWN_CONFIG>(const SG_PAWN_CONFIG& Value)
	{
		if(!Write<SG_ATTR_BASE_CONFIG>(Value.BaseConfig)) return false;
		if(!Write<SG_ATTR_MOD_CONFIG>(Value.SigmaConfig)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_PAWN_CONFIG_fieldinfo[] =
	{
		{TYPE_STRUCT, "BaseConfig", 0, ATLAS_OFFSETOF(SG_PAWN_CONFIG, BaseConfig), &_rfl_struct_SG_ATTR_BASE_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_BASE_CONFIG), NULL},
		{TYPE_STRUCT, "SigmaConfig", 0, ATLAS_OFFSETOF(SG_PAWN_CONFIG, SigmaConfig), &_rfl_struct_SG_ATTR_MOD_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_MOD_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_PAWN_CONFIG_info = { NULL, "SG_PAWN_CONFIG", sizeof(SG_PAWN_CONFIG), 2, _struct_SG_PAWN_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_PAWN_CONFIG>()
	{
		return &_rfl_struct_SG_PAWN_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ITEM_CONFIG>(SG_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.item_id)) return false;
		if(!Read<_U32>(Value.stack_max)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ITEM_CONFIG>(const SG_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.item_id)) return false;
		if(!Write<_U32>(Value.stack_max)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ITEM_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "item_id", 0, ATLAS_OFFSETOF(SG_ITEM_CONFIG, item_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "stack_max", 0, ATLAS_OFFSETOF(SG_ITEM_CONFIG, stack_max), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ITEM_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_ITEM_CONFIG", sizeof(SG_ITEM_CONFIG), 2, _struct_SG_ITEM_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIPT_ITEM_CONFIG>(SG_EQUIPT_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<SG_ITEM_CONFIG>(Value)) return false;
		if(!Read<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIPT_ITEM_CONFIG>(const SG_EQUIPT_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<SG_ITEM_CONFIG>(Value)) return false;
		if(!Write<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIPT_ITEM_CONFIG_fieldinfo[] =
	{
		{TYPE_STRUCT, "mod_config", 0, ATLAS_OFFSETOF(SG_EQUIPT_ITEM_CONFIG, mod_config), &_rfl_struct_SG_ATTR_MOD_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_MOD_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIPT_ITEM_CONFIG_info = { &_rfl_struct_SG_ITEM_CONFIG_info, "SG_EQUIPT_ITEM_CONFIG", sizeof(SG_EQUIPT_ITEM_CONFIG), 1, _struct_SG_EQUIPT_ITEM_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIPT_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_EQUIPT_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_USABLE_ITEM_CONFIG>(SG_USABLE_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<SG_ITEM_CONFIG>(Value)) return false;
		if(!ReadString<100>(Value.functional)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_USABLE_ITEM_CONFIG>(const SG_USABLE_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<SG_ITEM_CONFIG>(Value)) return false;
		if(!WriteString<100>(Value.functional)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_USABLE_ITEM_CONFIG_fieldinfo[] =
	{
		{TYPE_STRING, "functional", 0, ATLAS_OFFSETOF(SG_USABLE_ITEM_CONFIG, functional), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_USABLE_ITEM_CONFIG_info = { &_rfl_struct_SG_ITEM_CONFIG_info, "SG_USABLE_ITEM_CONFIG", sizeof(SG_USABLE_ITEM_CONFIG), 1, _struct_SG_USABLE_ITEM_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_USABLE_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_USABLE_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GEM_ITEM_CONFIG>(SG_GEM_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<SG_ITEM_CONFIG>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GEM_ITEM_CONFIG>(const SG_GEM_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<SG_ITEM_CONFIG>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{
	STRUCT_INFO _rfl_struct_SG_GEM_ITEM_CONFIG_info = { &_rfl_struct_SG_ITEM_CONFIG_info, "SG_GEM_ITEM_CONFIG", sizeof(SG_GEM_ITEM_CONFIG), 0, NULL };
	template<>
	const STRUCT_INFO* GetStruct<SG_GEM_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_GEM_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ENEMY_CONFIG>(SG_ENEMY_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.enemy_id)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Read<_U8>(Value.type)) return false;
		if(!Read<_S8>(Value.classes)) return false;
		if(!Read<_U16>(Value.atk_type)) return false;
		if(!Read<_U16>(Value.def_type)) return false;
		if(!Read<_S32>(Value.gift)) return false;
		if(!Read<_S32>(Value.com_atk_skill)) return false;
		if(!Read<_S32>(Value.sp_skill)) return false;
		if(!Read<_U32>(Value.atk_CD)) return false;
		if(!ReadString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Read<_S32>(Value.req_gold)) return false;
		if(!Read<_S32>(Value.req_rmb)) return false;
		if(!Read<_S32>(Value.unlock_level)) return false;
		if(!Read<_S32>(Value.pre_general_id)) return false;
		if(!Read<_S32>(Value.pre_level)) return false;
		if(!Read<_S32>(Value.product_consume)) return false;
		if(!Read<_S32>(Value.product_time)) return false;
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ENEMY_CONFIG>(const SG_ENEMY_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.enemy_id)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Write<_U8>(Value.type)) return false;
		if(!Write<_S8>(Value.classes)) return false;
		if(!Write<_U16>(Value.atk_type)) return false;
		if(!Write<_U16>(Value.def_type)) return false;
		if(!Write<_S32>(Value.gift)) return false;
		if(!Write<_S32>(Value.com_atk_skill)) return false;
		if(!Write<_S32>(Value.sp_skill)) return false;
		if(!Write<_U32>(Value.atk_CD)) return false;
		if(!WriteString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Write<_S32>(Value.req_gold)) return false;
		if(!Write<_S32>(Value.req_rmb)) return false;
		if(!Write<_S32>(Value.unlock_level)) return false;
		if(!Write<_S32>(Value.pre_general_id)) return false;
		if(!Write<_S32>(Value.pre_level)) return false;
		if(!Write<_S32>(Value.product_consume)) return false;
		if(!Write<_S32>(Value.product_time)) return false;
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ENEMY_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "enemy_id", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, enemy_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
		{TYPE_U8, "type", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U8), NULL},
		{TYPE_S8, "classes", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, classes), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S8), NULL},
		{TYPE_U16, "atk_type", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, atk_type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_U16, "def_type", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, def_type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_S32, "gift", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, gift), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "com_atk_skill", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, com_atk_skill), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "sp_skill", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, sp_skill), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_U32, "atk_CD", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, atk_CD), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRING, "description", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, description), NULL, (_U16)SG_DESCRIPTION_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_DESCRIPTION_MAX>), NULL},
		{TYPE_S32, "req_gold", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, req_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "req_rmb", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, req_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "unlock_level", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, unlock_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_general_id", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, pre_general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_level", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, pre_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "product_consume", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, product_consume), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "product_time", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, product_time), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_STRING, "archetype", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, archetype), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ENEMY_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_ENEMY_CONFIG", sizeof(SG_ENEMY_CONFIG), 20, _struct_SG_ENEMY_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ENEMY_CONFIG>()
	{
		return &_rfl_struct_SG_ENEMY_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_SOLDIER_LEVEL_CONFIG>(SG_SOLDIER_LEVEL_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!Read<_U32>(Value.level)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Read<_U32>(Value.exp)) return false;
		if(!Read<_S32>(Value.levelup_gold)) return false;
		if(!Read<_S32>(Value.levelup_rmb)) return false;
		if(!Read<_S32>(Value.levelup_XP)) return false;
		if(!Read<_U16>(Value.mod_scale)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_SOLDIER_LEVEL_CONFIG>(const SG_SOLDIER_LEVEL_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!Write<_U32>(Value.level)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Write<_U32>(Value.exp)) return false;
		if(!Write<_S32>(Value.levelup_gold)) return false;
		if(!Write<_S32>(Value.levelup_rmb)) return false;
		if(!Write<_S32>(Value.levelup_XP)) return false;
		if(!Write<_U16>(Value.mod_scale)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_SOLDIER_LEVEL_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "level", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
		{TYPE_U32, "exp", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, exp), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_S32, "levelup_gold", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, levelup_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_rmb", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, levelup_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_XP", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, levelup_XP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_U16, "mod_scale", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, mod_scale), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_SOLDIER_LEVEL_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_SOLDIER_LEVEL_CONFIG", sizeof(SG_SOLDIER_LEVEL_CONFIG), 8, _struct_SG_SOLDIER_LEVEL_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_SOLDIER_LEVEL_CONFIG>()
	{
		return &_rfl_struct_SG_SOLDIER_LEVEL_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GENERAL_LEVEL_CONFIG>(SG_GENERAL_LEVEL_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!Read<_U32>(Value.level)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Read<_U32>(Value.exp)) return false;
		if(!Read<_S32>(Value.levelup_gold)) return false;
		if(!Read<_S32>(Value.levelup_rmb)) return false;
		if(!Read<_S32>(Value.levelup_XP)) return false;
		if(!Read<_U16>(Value.mod_scale)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GENERAL_LEVEL_CONFIG>(const SG_GENERAL_LEVEL_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!Write<_U32>(Value.level)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Write<_U32>(Value.exp)) return false;
		if(!Write<_S32>(Value.levelup_gold)) return false;
		if(!Write<_S32>(Value.levelup_rmb)) return false;
		if(!Write<_S32>(Value.levelup_XP)) return false;
		if(!Write<_U16>(Value.mod_scale)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_GENERAL_LEVEL_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "level", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
		{TYPE_U32, "exp", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, exp), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_S32, "levelup_gold", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, levelup_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_rmb", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, levelup_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_XP", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, levelup_XP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_U16, "mod_scale", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, mod_scale), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_GENERAL_LEVEL_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_GENERAL_LEVEL_CONFIG", sizeof(SG_GENERAL_LEVEL_CONFIG), 8, _struct_SG_GENERAL_LEVEL_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_GENERAL_LEVEL_CONFIG>()
	{
		return &_rfl_struct_SG_GENERAL_LEVEL_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_SOLDIER_CONFIG>(SG_SOLDIER_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.soldier_id)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!Read<_U8>(Value.type)) return false;
		if(!Read<_S8>(Value.classes)) return false;
		if(!Read<_U16>(Value.atk_type)) return false;
		if(!Read<_U16>(Value.def_type)) return false;
		if(!Read<_S32>(Value.gift)) return false;
		if(!Read<_S32>(Value.com_atk_skill)) return false;
		if(!Read<_S32>(Value.sp_skill)) return false;
		if(!Read<_U32>(Value.atk_CD)) return false;
		if(!ReadString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Read<_S32>(Value.req_gold)) return false;
		if(!Read<_S32>(Value.req_rmb)) return false;
		if(!Read<_S32>(Value.unlock_level)) return false;
		if(!Read<_S32>(Value.pre_general_id)) return false;
		if(!Read<_S32>(Value.pre_level)) return false;
		if(!Read<_S32>(Value.product_consume)) return false;
		if(!Read<_S32>(Value.product_time)) return false;
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_SOLDIER_CONFIG>(const SG_SOLDIER_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.soldier_id)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!Write<_U8>(Value.type)) return false;
		if(!Write<_S8>(Value.classes)) return false;
		if(!Write<_U16>(Value.atk_type)) return false;
		if(!Write<_U16>(Value.def_type)) return false;
		if(!Write<_S32>(Value.gift)) return false;
		if(!Write<_S32>(Value.com_atk_skill)) return false;
		if(!Write<_S32>(Value.sp_skill)) return false;
		if(!Write<_U32>(Value.atk_CD)) return false;
		if(!WriteString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Write<_S32>(Value.req_gold)) return false;
		if(!Write<_S32>(Value.req_rmb)) return false;
		if(!Write<_S32>(Value.unlock_level)) return false;
		if(!Write<_S32>(Value.pre_general_id)) return false;
		if(!Write<_S32>(Value.pre_level)) return false;
		if(!Write<_S32>(Value.product_consume)) return false;
		if(!Write<_S32>(Value.product_time)) return false;
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_SOLDIER_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "soldier_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, soldier_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U8, "type", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U8), NULL},
		{TYPE_S8, "classes", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, classes), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S8), NULL},
		{TYPE_U16, "atk_type", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, atk_type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_U16, "def_type", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, def_type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_S32, "gift", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, gift), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "com_atk_skill", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, com_atk_skill), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "sp_skill", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, sp_skill), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_U32, "atk_CD", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, atk_CD), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRING, "description", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, description), NULL, (_U16)SG_DESCRIPTION_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_DESCRIPTION_MAX>), NULL},
		{TYPE_S32, "req_gold", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, req_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "req_rmb", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, req_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "unlock_level", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, unlock_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_general_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, pre_general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_level", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, pre_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "product_consume", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, product_consume), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "product_time", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, product_time), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_STRING, "archetype", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, archetype), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_SOLDIER_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_SOLDIER_CONFIG", sizeof(SG_SOLDIER_CONFIG), 19, _struct_SG_SOLDIER_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_SOLDIER_CONFIG>()
	{
		return &_rfl_struct_SG_SOLDIER_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GENERAL_CONFIG>(SG_GENERAL_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.general_id)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!Read<_U8>(Value.type)) return false;
		if(!Read<_S8>(Value.classes)) return false;
		if(!Read<_U16>(Value.atk_type)) return false;
		if(!Read<_U16>(Value.def_type)) return false;
		if(!Read<_S32>(Value.gift)) return false;
		if(!Read<_S32>(Value.com_atk_skill)) return false;
		if(!Read<_S32>(Value.sp_skill)) return false;
		if(!Read<_U32>(Value.atk_CD)) return false;
		if(!ReadString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Read<_U32>(Value.space)) return false;
		if(!Read<_S32>(Value.req_title)) return false;
		if(!Read<_S32>(Value.req_gold)) return false;
		if(!Read<_S32>(Value.req_rmb)) return false;
		if(!Read<_S32>(Value.unlock_level)) return false;
		if(!Read<_S32>(Value.pre_general_id)) return false;
		if(!Read<_S32>(Value.pre_level)) return false;
		if(!Read<_S32>(Value.product_consume)) return false;
		if(!Read<_S32>(Value.product_time)) return false;
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GENERAL_CONFIG>(const SG_GENERAL_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.general_id)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!Write<_U8>(Value.type)) return false;
		if(!Write<_S8>(Value.classes)) return false;
		if(!Write<_U16>(Value.atk_type)) return false;
		if(!Write<_U16>(Value.def_type)) return false;
		if(!Write<_S32>(Value.gift)) return false;
		if(!Write<_S32>(Value.com_atk_skill)) return false;
		if(!Write<_S32>(Value.sp_skill)) return false;
		if(!Write<_U32>(Value.atk_CD)) return false;
		if(!WriteString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Write<_U32>(Value.space)) return false;
		if(!Write<_S32>(Value.req_title)) return false;
		if(!Write<_S32>(Value.req_gold)) return false;
		if(!Write<_S32>(Value.req_rmb)) return false;
		if(!Write<_S32>(Value.unlock_level)) return false;
		if(!Write<_S32>(Value.pre_general_id)) return false;
		if(!Write<_S32>(Value.pre_level)) return false;
		if(!Write<_S32>(Value.product_consume)) return false;
		if(!Write<_S32>(Value.product_time)) return false;
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_GENERAL_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "general_id", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U8, "type", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U8), NULL},
		{TYPE_S8, "classes", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, classes), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S8), NULL},
		{TYPE_U16, "atk_type", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, atk_type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_U16, "def_type", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, def_type), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_S32, "gift", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, gift), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "com_atk_skill", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, com_atk_skill), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "sp_skill", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, sp_skill), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_U32, "atk_CD", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, atk_CD), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRING, "description", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, description), NULL, (_U16)SG_DESCRIPTION_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_DESCRIPTION_MAX>), NULL},
		{TYPE_U32, "space", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, space), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_S32, "req_title", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, req_title), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "req_gold", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, req_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "req_rmb", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, req_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "unlock_level", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, unlock_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_general_id", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, pre_general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_level", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, pre_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "product_consume", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, product_consume), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "product_time", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, product_time), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_STRING, "archetype", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, archetype), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_GENERAL_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_GENERAL_CONFIG", sizeof(SG_GENERAL_CONFIG), 21, _struct_SG_GENERAL_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_GENERAL_CONFIG>()
	{
		return &_rfl_struct_SG_GENERAL_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIPPED_UNIT_PVE>(SG_EQUIPPED_UNIT_PVE& Value)
	{
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIPPED_UNIT_PVE>(const SG_EQUIPPED_UNIT_PVE& Value)
	{
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIPPED_UNIT_PVE_fieldinfo[] =
	{
		{TYPE_STRING, "ArchetypeURL", 0, ATLAS_OFFSETOF(SG_EQUIPPED_UNIT_PVE, ArchetypeURL), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_EQUIPPED_UNIT_PVE, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIPPED_UNIT_PVE_info = { NULL, "SG_EQUIPPED_UNIT_PVE", sizeof(SG_EQUIPPED_UNIT_PVE), 2, _struct_SG_EQUIPPED_UNIT_PVE_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIPPED_UNIT_PVE>()
	{
		return &_rfl_struct_SG_EQUIPPED_UNIT_PVE_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_PLAYER_PVE>(SG_PLAYER_PVE& Value)
	{
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!ReadArray<SG_EQUIPPED_UNIT_PVE, 2>(Value.EquippedGenerals)) return false;
		if(!ReadArray<SG_EQUIPPED_UNIT_PVE, 3>(Value.EquippedSoldiers)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_PLAYER_PVE>(const SG_PLAYER_PVE& Value)
	{
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!WriteArray<SG_EQUIPPED_UNIT_PVE, 2>(Value.EquippedGenerals)) return false;
		if(!WriteArray<SG_EQUIPPED_UNIT_PVE, 3>(Value.EquippedSoldiers)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_PLAYER_PVE_fieldinfo[] =
	{
		{TYPE_STRING, "ArchetypeURL", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, ArchetypeURL), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
		{TYPE_STRUCT|TYPE_ARRAY, "EquippedGenerals", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, EquippedGenerals), &_rfl_struct_SG_EQUIPPED_UNIT_PVE_info, (_U16)-1, (_U16)2, (_U16)((size_t)(&((DDL::Array<SG_EQUIPPED_UNIT_PVE, 2>*)NULL)->_Array)), (_U16)sizeof(SG_EQUIPPED_UNIT_PVE), NULL},
		{TYPE_STRUCT|TYPE_ARRAY, "EquippedSoldiers", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, EquippedSoldiers), &_rfl_struct_SG_EQUIPPED_UNIT_PVE_info, (_U16)-1, (_U16)3, (_U16)((size_t)(&((DDL::Array<SG_EQUIPPED_UNIT_PVE, 3>*)NULL)->_Array)), (_U16)sizeof(SG_EQUIPPED_UNIT_PVE), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_PLAYER_PVE_info = { NULL, "SG_PLAYER_PVE", sizeof(SG_PLAYER_PVE), 4, _struct_SG_PLAYER_PVE_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_PLAYER_PVE>()
	{
		return &_rfl_struct_SG_PLAYER_PVE_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIP_SLOTS>(SG_EQUIP_SLOTS& Value)
	{
		if(!Read<A_UUID>(Value.head)) return false;
		if(!Read<A_UUID>(Value.hand)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIP_SLOTS>(const SG_EQUIP_SLOTS& Value)
	{
		if(!Write<A_UUID>(Value.head)) return false;
		if(!Write<A_UUID>(Value.hand)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIP_SLOTS_fieldinfo[] =
	{
		{TYPE_UUID, "head", 0, ATLAS_OFFSETOF(SG_EQUIP_SLOTS, head), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
		{TYPE_UUID, "hand", 0, ATLAS_OFFSETOF(SG_EQUIP_SLOTS, hand), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIP_SLOTS_info = { NULL, "SG_EQUIP_SLOTS", sizeof(SG_EQUIP_SLOTS), 2, _struct_SG_EQUIP_SLOTS_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIP_SLOTS>()
	{
		return &_rfl_struct_SG_EQUIP_SLOTS_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GENERAL>(SG_GENERAL& Value)
	{
		if(!BufferReader::Read<A_LIVE_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.general_id)) return false;
		if(!Read<_U16>(Value.level)) return false;
		if(!Read<_U32>(Value.exp)) return false;
		if(!Read<SG_EQUIP_SLOTS>(Value.equip_slots)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GENERAL>(const SG_GENERAL& Value)
	{
		if(!BufferWriter::Write<A_LIVE_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.general_id)) return false;
		if(!Write<_U16>(Value.level)) return false;
		if(!Write<_U32>(Value.exp)) return false;
		if(!Write<SG_EQUIP_SLOTS>(Value.equip_slots)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_GENERAL_fieldinfo[] =
	{
		{TYPE_U32, "general_id", 0, ATLAS_OFFSETOF(SG_GENERAL, general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U16, "level", 0, ATLAS_OFFSETOF(SG_GENERAL, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_U32, "exp", 0, ATLAS_OFFSETOF(SG_GENERAL, exp), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "equip_slots", 0, ATLAS_OFFSETOF(SG_GENERAL, equip_slots), &_rfl_struct_SG_EQUIP_SLOTS_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_EQUIP_SLOTS), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_GENERAL_info = { &_rfl_struct_A_LIVE_OBJECT_info, "SG_GENERAL", sizeof(SG_GENERAL), 4, _struct_SG_GENERAL_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_GENERAL>()
	{
		return &_rfl_struct_SG_GENERAL_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_SOLDIER>(SG_SOLDIER& Value)
	{
		if(!BufferReader::Read<A_LIVE_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.soldier_id)) return false;
		if(!Read<_U16>(Value.level)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_SOLDIER>(const SG_SOLDIER& Value)
	{
		if(!BufferWriter::Write<A_LIVE_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.soldier_id)) return false;
		if(!Write<_U16>(Value.level)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_SOLDIER_fieldinfo[] =
	{
		{TYPE_U32, "soldier_id", 0, ATLAS_OFFSETOF(SG_SOLDIER, soldier_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U16, "level", 0, ATLAS_OFFSETOF(SG_SOLDIER, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_SOLDIER_info = { &_rfl_struct_A_LIVE_OBJECT_info, "SG_SOLDIER", sizeof(SG_SOLDIER), 2, _struct_SG_SOLDIER_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_SOLDIER>()
	{
		return &_rfl_struct_SG_SOLDIER_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_PLAYER>(SG_PLAYER& Value)
	{
		if(!BufferReader::Read<SG_GENERAL>(Value)) return false;
		if(!ReadString<SG_PLAYERNAME_LENMAX>(Value.nick)) return false;
		if(!Read<_U32>(Value.gold)) return false;
		if(!Read<_U32>(Value.rmb)) return false;
		if(!ReadArray<_U16, 2>(Value.equip_generals)) return false;
		if(!ReadArray<_U16, 3>(Value.equip_soldiers)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_PLAYER>(const SG_PLAYER& Value)
	{
		if(!BufferWriter::Write<SG_GENERAL>(Value)) return false;
		if(!WriteString<SG_PLAYERNAME_LENMAX>(Value.nick)) return false;
		if(!Write<_U32>(Value.gold)) return false;
		if(!Write<_U32>(Value.rmb)) return false;
		if(!WriteArray<_U16, 2>(Value.equip_generals)) return false;
		if(!WriteArray<_U16, 3>(Value.equip_soldiers)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_PLAYER_fieldinfo[] =
	{
		{TYPE_STRING, "nick", 0, ATLAS_OFFSETOF(SG_PLAYER, nick), NULL, (_U16)SG_PLAYERNAME_LENMAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_PLAYERNAME_LENMAX>), NULL},
		{TYPE_U32, "gold", 0, ATLAS_OFFSETOF(SG_PLAYER, gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "rmb", 0, ATLAS_OFFSETOF(SG_PLAYER, rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U16|TYPE_ARRAY, "equip_generals", 0, ATLAS_OFFSETOF(SG_PLAYER, equip_generals), NULL, (_U16)-1, (_U16)2, (_U16)((size_t)(&((DDL::Array<_U16, 2>*)NULL)->_Array)), (_U16)sizeof(_U16), NULL},
		{TYPE_U16|TYPE_ARRAY, "equip_soldiers", 0, ATLAS_OFFSETOF(SG_PLAYER, equip_soldiers), NULL, (_U16)-1, (_U16)3, (_U16)((size_t)(&((DDL::Array<_U16, 3>*)NULL)->_Array)), (_U16)sizeof(_U16), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_PLAYER_info = { &_rfl_struct_SG_GENERAL_info, "SG_PLAYER", sizeof(SG_PLAYER), 5, _struct_SG_PLAYER_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_PLAYER>()
	{
		return &_rfl_struct_SG_PLAYER_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ITEM>(SG_ITEM& Value)
	{
		if(!BufferReader::Read<A_LIVE_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.item_id)) return false;
		if(!Read<_U32>(Value.count)) return false;
		if(!Read<_U32>(Value.expired_time)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ITEM>(const SG_ITEM& Value)
	{
		if(!BufferWriter::Write<A_LIVE_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.item_id)) return false;
		if(!Write<_U32>(Value.count)) return false;
		if(!Write<_U32>(Value.expired_time)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ITEM_fieldinfo[] =
	{
		{TYPE_U32, "item_id", 0, ATLAS_OFFSETOF(SG_ITEM, item_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "count", 0, ATLAS_OFFSETOF(SG_ITEM, count), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "expired_time", 0, ATLAS_OFFSETOF(SG_ITEM, expired_time), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ITEM_info = { &_rfl_struct_A_LIVE_OBJECT_info, "SG_ITEM", sizeof(SG_ITEM), 3, _struct_SG_ITEM_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ITEM>()
	{
		return &_rfl_struct_SG_ITEM_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIPT_ITEM>(SG_EQUIPT_ITEM& Value)
	{
		if(!BufferReader::Read<SG_ITEM>(Value)) return false;
		if(!Read<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIPT_ITEM>(const SG_EQUIPT_ITEM& Value)
	{
		if(!BufferWriter::Write<SG_ITEM>(Value)) return false;
		if(!Write<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIPT_ITEM_fieldinfo[] =
	{
		{TYPE_STRUCT, "mod_config", 0, ATLAS_OFFSETOF(SG_EQUIPT_ITEM, mod_config), &_rfl_struct_SG_ATTR_MOD_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_MOD_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIPT_ITEM_info = { &_rfl_struct_SG_ITEM_info, "SG_EQUIPT_ITEM", sizeof(SG_EQUIPT_ITEM), 1, _struct_SG_EQUIPT_ITEM_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIPT_ITEM>()
	{
		return &_rfl_struct_SG_EQUIPT_ITEM_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_USABLE_ITEM>(SG_USABLE_ITEM& Value)
	{
		if(!BufferReader::Read<SG_ITEM>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_USABLE_ITEM>(const SG_USABLE_ITEM& Value)
	{
		if(!BufferWriter::Write<SG_ITEM>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{
	STRUCT_INFO _rfl_struct_SG_USABLE_ITEM_info = { &_rfl_struct_SG_ITEM_info, "SG_USABLE_ITEM", sizeof(SG_USABLE_ITEM), 0, NULL };
	template<>
	const STRUCT_INFO* GetStruct<SG_USABLE_ITEM>()
	{
		return &_rfl_struct_SG_USABLE_ITEM_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GEM_ITEM>(SG_GEM_ITEM& Value)
	{
		if(!BufferReader::Read<SG_ITEM>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GEM_ITEM>(const SG_GEM_ITEM& Value)
	{
		if(!BufferWriter::Write<SG_ITEM>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{
	STRUCT_INFO _rfl_struct_SG_GEM_ITEM_info = { &_rfl_struct_SG_ITEM_info, "SG_GEM_ITEM", sizeof(SG_GEM_ITEM), 0, NULL };
	template<>
	const STRUCT_INFO* GetStruct<SG_GEM_ITEM>()
	{
		return &_rfl_struct_SG_GEM_ITEM_info;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _class_SGGAME_C2S_fieldinfos[] = 
	{
		// 0 CreateAvatar
		{TYPE_S8|TYPE_ARRAY, "name", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 1 QueryAvatar
		// 2 Ping
	};
	static FUNCTION_INFO _class_SGGAME_C2S_funcinfos[] = 
	{
		{"CreateAvatar", 1, _class_SGGAME_C2S_fieldinfos+0},
		{"QueryAvatar", 0, _class_SGGAME_C2S_fieldinfos+1},
		{"Ping", 0, _class_SGGAME_C2S_fieldinfos+1},
	};
	static CLASS_INFO _class_SGGAME_C2S_info = { 0, "SGGAME_C2S", 3, _class_SGGAME_C2S_funcinfos };
	template<>
	const CLASS_INFO* GetClass<SGGAME_C2S>()
	{
		return &_class_SGGAME_C2S_info;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _class_SGGAME_S2C_fieldinfos[] = 
	{
		// 0 CreatAvatarResult
		{TYPE_U32, "code", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 1 QueryAvatarResult
		{TYPE_U32, "code", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 2 Pong
	};
	static FUNCTION_INFO _class_SGGAME_S2C_funcinfos[] = 
	{
		{"CreatAvatarResult", 1, _class_SGGAME_S2C_fieldinfos+0},
		{"QueryAvatarResult", 1, _class_SGGAME_S2C_fieldinfos+1},
		{"Pong", 0, _class_SGGAME_S2C_fieldinfos+2},
	};
	static CLASS_INFO _class_SGGAME_S2C_info = { 0, "SGGAME_S2C", 3, _class_SGGAME_S2C_funcinfos };
	template<>
	const CLASS_INFO* GetClass<SGGAME_S2C>()
	{
		return &_class_SGGAME_S2C_info;
	}
}

