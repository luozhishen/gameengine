////////////////////////////////////////////////
// THIS FILE IS AUTOGENERATED. DO NOT MODIFY! //
////////////////////////////////////////////////

#include "SGGameDDL.h"

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_PLAYER_RANDOM_NAME_CONFIG>(SG_PLAYER_RANDOM_NAME_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!ReadString<SG_PLAYER_NAME_MAX>(Value.family_name)) return false;
		if(!ReadString<SG_PLAYER_NAME_MAX>(Value.male_name)) return false;
		if(!ReadString<SG_PLAYER_NAME_MAX>(Value.female_name)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_PLAYER_RANDOM_NAME_CONFIG>(const SG_PLAYER_RANDOM_NAME_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!WriteString<SG_PLAYER_NAME_MAX>(Value.family_name)) return false;
		if(!WriteString<SG_PLAYER_NAME_MAX>(Value.male_name)) return false;
		if(!WriteString<SG_PLAYER_NAME_MAX>(Value.female_name)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_PLAYER_RANDOM_NAME_CONFIG_fieldinfo[] =
	{
		{TYPE_STRING, "family_name", 0, ATLAS_OFFSETOF(SG_PLAYER_RANDOM_NAME_CONFIG, family_name), NULL, (_U16)SG_PLAYER_NAME_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_PLAYER_NAME_MAX>), NULL},
		{TYPE_STRING, "male_name", 0, ATLAS_OFFSETOF(SG_PLAYER_RANDOM_NAME_CONFIG, male_name), NULL, (_U16)SG_PLAYER_NAME_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_PLAYER_NAME_MAX>), NULL},
		{TYPE_STRING, "female_name", 0, ATLAS_OFFSETOF(SG_PLAYER_RANDOM_NAME_CONFIG, female_name), NULL, (_U16)SG_PLAYER_NAME_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_PLAYER_NAME_MAX>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_PLAYER_RANDOM_NAME_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_PLAYER_RANDOM_NAME_CONFIG", sizeof(SG_PLAYER_RANDOM_NAME_CONFIG), 3, _struct_SG_PLAYER_RANDOM_NAME_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_PLAYER_RANDOM_NAME_CONFIG>()
	{
		return &_rfl_struct_SG_PLAYER_RANDOM_NAME_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_LEVEL_DROP_CONFIG>(SG_LEVEL_DROP_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!ReadString<100>(Value.level_name)) return false;
		if(!Read<_U32>(Value.exp)) return false;
		if(!Read<_U32>(Value.gold)) return false;
		if(!Read<_U32>(Value.group1_id)) return false;
		if(!Read<_F32>(Value.group1_rate)) return false;
		if(!Read<_U32>(Value.group2_id)) return false;
		if(!Read<_F32>(Value.group2_rate)) return false;
		if(!Read<_U32>(Value.group3_id)) return false;
		if(!Read<_F32>(Value.group3_rate)) return false;
		if(!Read<_U32>(Value.group4_id)) return false;
		if(!Read<_F32>(Value.group4_rate)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_LEVEL_DROP_CONFIG>(const SG_LEVEL_DROP_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!WriteString<100>(Value.level_name)) return false;
		if(!Write<_U32>(Value.exp)) return false;
		if(!Write<_U32>(Value.gold)) return false;
		if(!Write<_U32>(Value.group1_id)) return false;
		if(!Write<_F32>(Value.group1_rate)) return false;
		if(!Write<_U32>(Value.group2_id)) return false;
		if(!Write<_F32>(Value.group2_rate)) return false;
		if(!Write<_U32>(Value.group3_id)) return false;
		if(!Write<_F32>(Value.group3_rate)) return false;
		if(!Write<_U32>(Value.group4_id)) return false;
		if(!Write<_F32>(Value.group4_rate)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_LEVEL_DROP_CONFIG_fieldinfo[] =
	{
		{TYPE_STRING, "level_name", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, level_name), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
		{TYPE_U32, "exp", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, exp), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "gold", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "group1_id", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group1_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_F32, "group1_rate", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group1_rate), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_U32, "group2_id", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group2_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_F32, "group2_rate", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group2_rate), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_U32, "group3_id", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group3_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_F32, "group3_rate", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group3_rate), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_U32, "group4_id", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group4_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_F32, "group4_rate", 0, ATLAS_OFFSETOF(SG_LEVEL_DROP_CONFIG, group4_rate), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_LEVEL_DROP_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_LEVEL_DROP_CONFIG", sizeof(SG_LEVEL_DROP_CONFIG), 11, _struct_SG_LEVEL_DROP_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_LEVEL_DROP_CONFIG>()
	{
		return &_rfl_struct_SG_LEVEL_DROP_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_DROP_ITEM_BASE>(SG_DROP_ITEM_BASE& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.item_id)) return false;
		if(!Read<_U32>(Value.count)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_DROP_ITEM_BASE>(const SG_DROP_ITEM_BASE& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.item_id)) return false;
		if(!Write<_U32>(Value.count)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_DROP_ITEM_BASE_fieldinfo[] =
	{
		{TYPE_U32, "item_id", 0, ATLAS_OFFSETOF(SG_DROP_ITEM_BASE, item_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "count", 0, ATLAS_OFFSETOF(SG_DROP_ITEM_BASE, count), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_DROP_ITEM_BASE_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_DROP_ITEM_BASE", sizeof(SG_DROP_ITEM_BASE), 2, _struct_SG_DROP_ITEM_BASE_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_DROP_ITEM_BASE>()
	{
		return &_rfl_struct_SG_DROP_ITEM_BASE_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_DROP_ITEM_CONFIG>(SG_DROP_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<SG_DROP_ITEM_BASE>(Value)) return false;
		if(!Read<_U32>(Value.group_id)) return false;
		if(!Read<_F32>(Value.rate)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_DROP_ITEM_CONFIG>(const SG_DROP_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<SG_DROP_ITEM_BASE>(Value)) return false;
		if(!Write<_U32>(Value.group_id)) return false;
		if(!Write<_F32>(Value.rate)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_DROP_ITEM_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "group_id", 0, ATLAS_OFFSETOF(SG_DROP_ITEM_CONFIG, group_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_F32, "rate", 0, ATLAS_OFFSETOF(SG_DROP_ITEM_CONFIG, rate), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_DROP_ITEM_CONFIG_info = { &_rfl_struct_SG_DROP_ITEM_BASE_info, "SG_DROP_ITEM_CONFIG", sizeof(SG_DROP_ITEM_CONFIG), 2, _struct_SG_DROP_ITEM_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_DROP_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_DROP_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ATTR_MOD_CONFIG>(SG_ATTR_MOD_CONFIG& Value)
	{
		if(!Read<_F32>(Value.MOD_HPAddition)) return false;
		if(!Read<_F32>(Value.MOD_HPPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraHP)) return false;
		if(!Read<_F32>(Value.MOD_ATKAddition)) return false;
		if(!Read<_F32>(Value.MOD_ATKPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraATK)) return false;
		if(!Read<_F32>(Value.MOD_DEFAddition)) return false;
		if(!Read<_F32>(Value.MOD_DEFPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraDEF)) return false;
		if(!Read<_F32>(Value.MOD_HITAddition)) return false;
		if(!Read<_F32>(Value.MOD_EvasionAddition)) return false;
		if(!Read<_F32>(Value.MOD_CRITAddition)) return false;
		if(!Read<_F32>(Value.MOD_SPAddition)) return false;
		if(!Read<_F32>(Value.MOD_WSAddition)) return false;
		if(!Read<_F32>(Value.MOD_WSPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraWS)) return false;
		if(!Read<_F32>(Value.MOD_STRAddition)) return false;
		if(!Read<_F32>(Value.MOD_STRPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraSTR)) return false;
		if(!Read<_F32>(Value.MOD_INTAddition)) return false;
		if(!Read<_F32>(Value.MOD_INTPercent)) return false;
		if(!Read<_F32>(Value.MOD_ExtraINT)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ATTR_MOD_CONFIG>(const SG_ATTR_MOD_CONFIG& Value)
	{
		if(!Write<_F32>(Value.MOD_HPAddition)) return false;
		if(!Write<_F32>(Value.MOD_HPPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraHP)) return false;
		if(!Write<_F32>(Value.MOD_ATKAddition)) return false;
		if(!Write<_F32>(Value.MOD_ATKPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraATK)) return false;
		if(!Write<_F32>(Value.MOD_DEFAddition)) return false;
		if(!Write<_F32>(Value.MOD_DEFPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraDEF)) return false;
		if(!Write<_F32>(Value.MOD_HITAddition)) return false;
		if(!Write<_F32>(Value.MOD_EvasionAddition)) return false;
		if(!Write<_F32>(Value.MOD_CRITAddition)) return false;
		if(!Write<_F32>(Value.MOD_SPAddition)) return false;
		if(!Write<_F32>(Value.MOD_WSAddition)) return false;
		if(!Write<_F32>(Value.MOD_WSPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraWS)) return false;
		if(!Write<_F32>(Value.MOD_STRAddition)) return false;
		if(!Write<_F32>(Value.MOD_STRPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraSTR)) return false;
		if(!Write<_F32>(Value.MOD_INTAddition)) return false;
		if(!Write<_F32>(Value.MOD_INTPercent)) return false;
		if(!Write<_F32>(Value.MOD_ExtraINT)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ATTR_MOD_CONFIG_fieldinfo[] =
	{
		{TYPE_F32, "MOD_HPAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_HPAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_HPPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_HPPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraHP", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraHP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ATKAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ATKAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ATKPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ATKPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraATK", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraATK), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_DEFAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_DEFAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_DEFPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_DEFPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraDEF", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraDEF), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_HITAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_HITAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_EvasionAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_EvasionAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_CRITAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_CRITAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_SPAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_SPAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_WSAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_WSAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_WSPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_WSPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraWS", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraWS), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_STRAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_STRAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_STRPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_STRPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraSTR", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraSTR), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_INTAddition", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_INTAddition), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_INTPercent", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_INTPercent), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "MOD_ExtraINT", 0, ATLAS_OFFSETOF(SG_ATTR_MOD_CONFIG, MOD_ExtraINT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ATTR_MOD_CONFIG_info = { NULL, "SG_ATTR_MOD_CONFIG", sizeof(SG_ATTR_MOD_CONFIG), 22, _struct_SG_ATTR_MOD_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ATTR_MOD_CONFIG>()
	{
		return &_rfl_struct_SG_ATTR_MOD_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ATTR_BASE_CONFIG>(SG_ATTR_BASE_CONFIG& Value)
	{
		if(!Read<_F32>(Value.Base_HP)) return false;
		if(!Read<_F32>(Value.Base_ATK)) return false;
		if(!Read<_F32>(Value.Base_DEF)) return false;
		if(!Read<_F32>(Value.Base_HIT)) return false;
		if(!Read<_F32>(Value.Base_Evasion)) return false;
		if(!Read<_F32>(Value.Base_CRIT)) return false;
		if(!Read<_F32>(Value.Base_SP)) return false;
		if(!Read<_F32>(Value.Base_WS)) return false;
		if(!Read<_F32>(Value.Base_STR)) return false;
		if(!Read<_F32>(Value.Base_INT)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ATTR_BASE_CONFIG>(const SG_ATTR_BASE_CONFIG& Value)
	{
		if(!Write<_F32>(Value.Base_HP)) return false;
		if(!Write<_F32>(Value.Base_ATK)) return false;
		if(!Write<_F32>(Value.Base_DEF)) return false;
		if(!Write<_F32>(Value.Base_HIT)) return false;
		if(!Write<_F32>(Value.Base_Evasion)) return false;
		if(!Write<_F32>(Value.Base_CRIT)) return false;
		if(!Write<_F32>(Value.Base_SP)) return false;
		if(!Write<_F32>(Value.Base_WS)) return false;
		if(!Write<_F32>(Value.Base_STR)) return false;
		if(!Write<_F32>(Value.Base_INT)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ATTR_BASE_CONFIG_fieldinfo[] =
	{
		{TYPE_F32, "Base_HP", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_HP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_ATK", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_ATK), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_DEF", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_DEF), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_HIT", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_HIT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_Evasion", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_Evasion), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_CRIT", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_CRIT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_SP", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_SP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_WS", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_WS), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_STR", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_STR), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
		{TYPE_F32, "Base_INT", 0, ATLAS_OFFSETOF(SG_ATTR_BASE_CONFIG, Base_INT), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_F32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ATTR_BASE_CONFIG_info = { NULL, "SG_ATTR_BASE_CONFIG", sizeof(SG_ATTR_BASE_CONFIG), 10, _struct_SG_ATTR_BASE_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ATTR_BASE_CONFIG>()
	{
		return &_rfl_struct_SG_ATTR_BASE_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_PAWN_CONFIG>(SG_PAWN_CONFIG& Value)
	{
		if(!Read<SG_ATTR_BASE_CONFIG>(Value.BaseConfig)) return false;
		if(!Read<SG_ATTR_MOD_CONFIG>(Value.SigmaConfig)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_PAWN_CONFIG>(const SG_PAWN_CONFIG& Value)
	{
		if(!Write<SG_ATTR_BASE_CONFIG>(Value.BaseConfig)) return false;
		if(!Write<SG_ATTR_MOD_CONFIG>(Value.SigmaConfig)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_PAWN_CONFIG_fieldinfo[] =
	{
		{TYPE_STRUCT, "BaseConfig", 0, ATLAS_OFFSETOF(SG_PAWN_CONFIG, BaseConfig), &_rfl_struct_SG_ATTR_BASE_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_BASE_CONFIG), NULL},
		{TYPE_STRUCT, "SigmaConfig", 0, ATLAS_OFFSETOF(SG_PAWN_CONFIG, SigmaConfig), &_rfl_struct_SG_ATTR_MOD_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_MOD_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_PAWN_CONFIG_info = { NULL, "SG_PAWN_CONFIG", sizeof(SG_PAWN_CONFIG), 2, _struct_SG_PAWN_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_PAWN_CONFIG>()
	{
		return &_rfl_struct_SG_PAWN_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ITEM_CONFIG>(SG_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.item_id)) return false;
		if(!Read<_U32>(Value.stack_max)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ITEM_CONFIG>(const SG_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.item_id)) return false;
		if(!Write<_U32>(Value.stack_max)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ITEM_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "item_id", 0, ATLAS_OFFSETOF(SG_ITEM_CONFIG, item_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "stack_max", 0, ATLAS_OFFSETOF(SG_ITEM_CONFIG, stack_max), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ITEM_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_ITEM_CONFIG", sizeof(SG_ITEM_CONFIG), 2, _struct_SG_ITEM_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIPT_ITEM_CONFIG>(SG_EQUIPT_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<SG_ITEM_CONFIG>(Value)) return false;
		if(!Read<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIPT_ITEM_CONFIG>(const SG_EQUIPT_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<SG_ITEM_CONFIG>(Value)) return false;
		if(!Write<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIPT_ITEM_CONFIG_fieldinfo[] =
	{
		{TYPE_STRUCT, "mod_config", 0, ATLAS_OFFSETOF(SG_EQUIPT_ITEM_CONFIG, mod_config), &_rfl_struct_SG_ATTR_MOD_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_MOD_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIPT_ITEM_CONFIG_info = { &_rfl_struct_SG_ITEM_CONFIG_info, "SG_EQUIPT_ITEM_CONFIG", sizeof(SG_EQUIPT_ITEM_CONFIG), 1, _struct_SG_EQUIPT_ITEM_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIPT_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_EQUIPT_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_USABLE_ITEM_CONFIG>(SG_USABLE_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<SG_ITEM_CONFIG>(Value)) return false;
		if(!ReadString<100>(Value.functional)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_USABLE_ITEM_CONFIG>(const SG_USABLE_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<SG_ITEM_CONFIG>(Value)) return false;
		if(!WriteString<100>(Value.functional)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_USABLE_ITEM_CONFIG_fieldinfo[] =
	{
		{TYPE_STRING, "functional", 0, ATLAS_OFFSETOF(SG_USABLE_ITEM_CONFIG, functional), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_USABLE_ITEM_CONFIG_info = { &_rfl_struct_SG_ITEM_CONFIG_info, "SG_USABLE_ITEM_CONFIG", sizeof(SG_USABLE_ITEM_CONFIG), 1, _struct_SG_USABLE_ITEM_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_USABLE_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_USABLE_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GEM_ITEM_CONFIG>(SG_GEM_ITEM_CONFIG& Value)
	{
		if(!BufferReader::Read<SG_ITEM_CONFIG>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GEM_ITEM_CONFIG>(const SG_GEM_ITEM_CONFIG& Value)
	{
		if(!BufferWriter::Write<SG_ITEM_CONFIG>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{
	STRUCT_INFO _rfl_struct_SG_GEM_ITEM_CONFIG_info = { &_rfl_struct_SG_ITEM_CONFIG_info, "SG_GEM_ITEM_CONFIG", sizeof(SG_GEM_ITEM_CONFIG), 0, NULL };
	template<>
	const STRUCT_INFO* GetStruct<SG_GEM_ITEM_CONFIG>()
	{
		return &_rfl_struct_SG_GEM_ITEM_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ENEMY_CONFIG>(SG_ENEMY_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.enemy_id)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ENEMY_CONFIG>(const SG_ENEMY_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.enemy_id)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ENEMY_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "enemy_id", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, enemy_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_ENEMY_CONFIG, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ENEMY_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_ENEMY_CONFIG", sizeof(SG_ENEMY_CONFIG), 2, _struct_SG_ENEMY_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ENEMY_CONFIG>()
	{
		return &_rfl_struct_SG_ENEMY_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_SOLDIER_LEVEL_CONFIG>(SG_SOLDIER_LEVEL_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!Read<_U32>(Value.level)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Read<_U32>(Value.exp)) return false;
		if(!Read<_S32>(Value.levelup_gold)) return false;
		if(!Read<_S32>(Value.levelup_rmb)) return false;
		if(!Read<_S32>(Value.levelup_XP)) return false;
		if(!Read<_U16>(Value.mod_scale)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_SOLDIER_LEVEL_CONFIG>(const SG_SOLDIER_LEVEL_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!Write<_U32>(Value.level)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Write<_U32>(Value.exp)) return false;
		if(!Write<_S32>(Value.levelup_gold)) return false;
		if(!Write<_S32>(Value.levelup_rmb)) return false;
		if(!Write<_S32>(Value.levelup_XP)) return false;
		if(!Write<_U16>(Value.mod_scale)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_SOLDIER_LEVEL_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "level", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
		{TYPE_U32, "exp", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, exp), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_S32, "levelup_gold", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, levelup_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_rmb", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, levelup_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_XP", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, levelup_XP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_U16, "mod_scale", 0, ATLAS_OFFSETOF(SG_SOLDIER_LEVEL_CONFIG, mod_scale), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_SOLDIER_LEVEL_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_SOLDIER_LEVEL_CONFIG", sizeof(SG_SOLDIER_LEVEL_CONFIG), 8, _struct_SG_SOLDIER_LEVEL_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_SOLDIER_LEVEL_CONFIG>()
	{
		return &_rfl_struct_SG_SOLDIER_LEVEL_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GENERAL_LEVEL_CONFIG>(SG_GENERAL_LEVEL_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!Read<_U32>(Value.level)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Read<_S32>(Value.levelup_gold)) return false;
		if(!Read<_S32>(Value.levelup_rmb)) return false;
		if(!Read<_S32>(Value.levelup_XP)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GENERAL_LEVEL_CONFIG>(const SG_GENERAL_LEVEL_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!Write<_U32>(Value.level)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!Write<_S32>(Value.levelup_gold)) return false;
		if(!Write<_S32>(Value.levelup_rmb)) return false;
		if(!Write<_S32>(Value.levelup_XP)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_GENERAL_LEVEL_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "level", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
		{TYPE_S32, "levelup_gold", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, levelup_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_rmb", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, levelup_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "levelup_XP", 0, ATLAS_OFFSETOF(SG_GENERAL_LEVEL_CONFIG, levelup_XP), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_GENERAL_LEVEL_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_GENERAL_LEVEL_CONFIG", sizeof(SG_GENERAL_LEVEL_CONFIG), 6, _struct_SG_GENERAL_LEVEL_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_GENERAL_LEVEL_CONFIG>()
	{
		return &_rfl_struct_SG_GENERAL_LEVEL_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_SOLDIER_CONFIG>(SG_SOLDIER_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.soldier_id)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!ReadString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Read<_S32>(Value.req_gold)) return false;
		if(!Read<_S32>(Value.req_rmb)) return false;
		if(!Read<_S32>(Value.unlock_level)) return false;
		if(!Read<_S32>(Value.pre_general_id)) return false;
		if(!Read<_S32>(Value.pre_level)) return false;
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_SOLDIER_CONFIG>(const SG_SOLDIER_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.soldier_id)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!WriteString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Write<_S32>(Value.req_gold)) return false;
		if(!Write<_S32>(Value.req_rmb)) return false;
		if(!Write<_S32>(Value.unlock_level)) return false;
		if(!Write<_S32>(Value.pre_general_id)) return false;
		if(!Write<_S32>(Value.pre_level)) return false;
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_SOLDIER_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "soldier_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, soldier_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRING, "description", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, description), NULL, (_U16)SG_DESCRIPTION_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_DESCRIPTION_MAX>), NULL},
		{TYPE_S32, "req_gold", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, req_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "req_rmb", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, req_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "unlock_level", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, unlock_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_general_id", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, pre_general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_level", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, pre_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_STRING, "archetype", 0, ATLAS_OFFSETOF(SG_SOLDIER_CONFIG, archetype), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_SOLDIER_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_SOLDIER_CONFIG", sizeof(SG_SOLDIER_CONFIG), 9, _struct_SG_SOLDIER_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_SOLDIER_CONFIG>()
	{
		return &_rfl_struct_SG_SOLDIER_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GENERAL_CONFIG>(SG_GENERAL_CONFIG& Value)
	{
		if(!BufferReader::Read<A_CONTENT_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.general_id)) return false;
		if(!Read<_U32>(Value.attr_id)) return false;
		if(!ReadString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Read<_S32>(Value.req_title)) return false;
		if(!Read<_S32>(Value.req_gold)) return false;
		if(!Read<_S32>(Value.req_rmb)) return false;
		if(!Read<_S32>(Value.unlock_level)) return false;
		if(!Read<_S32>(Value.pre_general_id)) return false;
		if(!Read<_S32>(Value.pre_level)) return false;
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GENERAL_CONFIG>(const SG_GENERAL_CONFIG& Value)
	{
		if(!BufferWriter::Write<A_CONTENT_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.general_id)) return false;
		if(!Write<_U32>(Value.attr_id)) return false;
		if(!WriteString<SG_DESCRIPTION_MAX>(Value.description)) return false;
		if(!Write<_S32>(Value.req_title)) return false;
		if(!Write<_S32>(Value.req_gold)) return false;
		if(!Write<_S32>(Value.req_rmb)) return false;
		if(!Write<_S32>(Value.unlock_level)) return false;
		if(!Write<_S32>(Value.pre_general_id)) return false;
		if(!Write<_S32>(Value.pre_level)) return false;
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.archetype)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_GENERAL_CONFIG_fieldinfo[] =
	{
		{TYPE_U32, "general_id", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "attr_id", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, attr_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRING, "description", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, description), NULL, (_U16)SG_DESCRIPTION_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_DESCRIPTION_MAX>), NULL},
		{TYPE_S32, "req_title", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, req_title), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "req_gold", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, req_gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "req_rmb", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, req_rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "unlock_level", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, unlock_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_general_id", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, pre_general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_S32, "pre_level", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, pre_level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_S32), NULL},
		{TYPE_STRING, "archetype", 0, ATLAS_OFFSETOF(SG_GENERAL_CONFIG, archetype), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_GENERAL_CONFIG_info = { &_rfl_struct_A_CONTENT_OBJECT_info, "SG_GENERAL_CONFIG", sizeof(SG_GENERAL_CONFIG), 10, _struct_SG_GENERAL_CONFIG_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_GENERAL_CONFIG>()
	{
		return &_rfl_struct_SG_GENERAL_CONFIG_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIPPED_UNIT_PVE>(SG_EQUIPPED_UNIT_PVE& Value)
	{
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIPPED_UNIT_PVE>(const SG_EQUIPPED_UNIT_PVE& Value)
	{
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIPPED_UNIT_PVE_fieldinfo[] =
	{
		{TYPE_STRING, "ArchetypeURL", 0, ATLAS_OFFSETOF(SG_EQUIPPED_UNIT_PVE, ArchetypeURL), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_EQUIPPED_UNIT_PVE, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIPPED_UNIT_PVE_info = { NULL, "SG_EQUIPPED_UNIT_PVE", sizeof(SG_EQUIPPED_UNIT_PVE), 2, _struct_SG_EQUIPPED_UNIT_PVE_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIPPED_UNIT_PVE>()
	{
		return &_rfl_struct_SG_EQUIPPED_UNIT_PVE_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_PLAYER_PVE>(SG_PLAYER_PVE& Value)
	{
		if(!ReadString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Read<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!ReadArray<SG_EQUIPPED_UNIT_PVE, 2>(Value.EquippedGenerals)) return false;
		if(!ReadArray<SG_EQUIPPED_UNIT_PVE, 3>(Value.EquippedSoldiers)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_PLAYER_PVE>(const SG_PLAYER_PVE& Value)
	{
		if(!WriteString<ARCHETYPE_URL_LENGTH_MAX>(Value.ArchetypeURL)) return false;
		if(!Write<SG_PAWN_CONFIG>(Value.PawnConfig)) return false;
		if(!WriteArray<SG_EQUIPPED_UNIT_PVE, 2>(Value.EquippedGenerals)) return false;
		if(!WriteArray<SG_EQUIPPED_UNIT_PVE, 3>(Value.EquippedSoldiers)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_PLAYER_PVE_fieldinfo[] =
	{
		{TYPE_STRING, "ArchetypeURL", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, ArchetypeURL), NULL, (_U16)ARCHETYPE_URL_LENGTH_MAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<ARCHETYPE_URL_LENGTH_MAX>), NULL},
		{TYPE_STRUCT, "PawnConfig", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, PawnConfig), &_rfl_struct_SG_PAWN_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_PAWN_CONFIG), NULL},
		{TYPE_STRUCT|TYPE_ARRAY, "EquippedGenerals", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, EquippedGenerals), &_rfl_struct_SG_EQUIPPED_UNIT_PVE_info, (_U16)-1, (_U16)2, (_U16)((size_t)(&((DDL::Array<SG_EQUIPPED_UNIT_PVE, 2>*)NULL)->_Array)), (_U16)sizeof(SG_EQUIPPED_UNIT_PVE), NULL},
		{TYPE_STRUCT|TYPE_ARRAY, "EquippedSoldiers", 0, ATLAS_OFFSETOF(SG_PLAYER_PVE, EquippedSoldiers), &_rfl_struct_SG_EQUIPPED_UNIT_PVE_info, (_U16)-1, (_U16)3, (_U16)((size_t)(&((DDL::Array<SG_EQUIPPED_UNIT_PVE, 3>*)NULL)->_Array)), (_U16)sizeof(SG_EQUIPPED_UNIT_PVE), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_PLAYER_PVE_info = { NULL, "SG_PLAYER_PVE", sizeof(SG_PLAYER_PVE), 4, _struct_SG_PLAYER_PVE_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_PLAYER_PVE>()
	{
		return &_rfl_struct_SG_PLAYER_PVE_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIP_SLOTS>(SG_EQUIP_SLOTS& Value)
	{
		if(!Read<A_UUID>(Value.head)) return false;
		if(!Read<A_UUID>(Value.hand)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIP_SLOTS>(const SG_EQUIP_SLOTS& Value)
	{
		if(!Write<A_UUID>(Value.head)) return false;
		if(!Write<A_UUID>(Value.hand)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIP_SLOTS_fieldinfo[] =
	{
		{TYPE_UUID, "head", 0, ATLAS_OFFSETOF(SG_EQUIP_SLOTS, head), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
		{TYPE_UUID, "hand", 0, ATLAS_OFFSETOF(SG_EQUIP_SLOTS, hand), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIP_SLOTS_info = { NULL, "SG_EQUIP_SLOTS", sizeof(SG_EQUIP_SLOTS), 2, _struct_SG_EQUIP_SLOTS_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIP_SLOTS>()
	{
		return &_rfl_struct_SG_EQUIP_SLOTS_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GENERAL>(SG_GENERAL& Value)
	{
		if(!BufferReader::Read<A_LIVE_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.general_id)) return false;
		if(!Read<_U16>(Value.level)) return false;
		if(!Read<_U32>(Value.exp)) return false;
		if(!Read<SG_EQUIP_SLOTS>(Value.equip_slots)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GENERAL>(const SG_GENERAL& Value)
	{
		if(!BufferWriter::Write<A_LIVE_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.general_id)) return false;
		if(!Write<_U16>(Value.level)) return false;
		if(!Write<_U32>(Value.exp)) return false;
		if(!Write<SG_EQUIP_SLOTS>(Value.equip_slots)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_GENERAL_fieldinfo[] =
	{
		{TYPE_U32, "general_id", 0, ATLAS_OFFSETOF(SG_GENERAL, general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U16, "level", 0, ATLAS_OFFSETOF(SG_GENERAL, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
		{TYPE_U32, "exp", 0, ATLAS_OFFSETOF(SG_GENERAL, exp), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRUCT, "equip_slots", 0, ATLAS_OFFSETOF(SG_GENERAL, equip_slots), &_rfl_struct_SG_EQUIP_SLOTS_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_EQUIP_SLOTS), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_GENERAL_info = { &_rfl_struct_A_LIVE_OBJECT_info, "SG_GENERAL", sizeof(SG_GENERAL), 4, _struct_SG_GENERAL_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_GENERAL>()
	{
		return &_rfl_struct_SG_GENERAL_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_SOLDIER>(SG_SOLDIER& Value)
	{
		if(!BufferReader::Read<A_LIVE_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.soldier_id)) return false;
		if(!Read<_U16>(Value.level)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_SOLDIER>(const SG_SOLDIER& Value)
	{
		if(!BufferWriter::Write<A_LIVE_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.soldier_id)) return false;
		if(!Write<_U16>(Value.level)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_SOLDIER_fieldinfo[] =
	{
		{TYPE_U32, "soldier_id", 0, ATLAS_OFFSETOF(SG_SOLDIER, soldier_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U16, "level", 0, ATLAS_OFFSETOF(SG_SOLDIER, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U16), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_SOLDIER_info = { &_rfl_struct_A_LIVE_OBJECT_info, "SG_SOLDIER", sizeof(SG_SOLDIER), 2, _struct_SG_SOLDIER_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_SOLDIER>()
	{
		return &_rfl_struct_SG_SOLDIER_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_PLAYER>(SG_PLAYER& Value)
	{
		if(!BufferReader::Read<SG_GENERAL>(Value)) return false;
		if(!ReadString<SG_PLAYERNAME_LENMAX>(Value.nick)) return false;
		if(!Read<_U32>(Value.gold)) return false;
		if(!Read<_U32>(Value.rmb)) return false;
		if(!ReadArray<_U32, 2>(Value.equip_generals)) return false;
		if(!ReadArray<_U32, 3>(Value.equip_soldiers)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_PLAYER>(const SG_PLAYER& Value)
	{
		if(!BufferWriter::Write<SG_GENERAL>(Value)) return false;
		if(!WriteString<SG_PLAYERNAME_LENMAX>(Value.nick)) return false;
		if(!Write<_U32>(Value.gold)) return false;
		if(!Write<_U32>(Value.rmb)) return false;
		if(!WriteArray<_U32, 2>(Value.equip_generals)) return false;
		if(!WriteArray<_U32, 3>(Value.equip_soldiers)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_PLAYER_fieldinfo[] =
	{
		{TYPE_STRING, "nick", 0, ATLAS_OFFSETOF(SG_PLAYER, nick), NULL, (_U16)SG_PLAYERNAME_LENMAX, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<SG_PLAYERNAME_LENMAX>), NULL},
		{TYPE_U32, "gold", 0, ATLAS_OFFSETOF(SG_PLAYER, gold), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "rmb", 0, ATLAS_OFFSETOF(SG_PLAYER, rmb), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32|TYPE_ARRAY, "equip_generals", 0, ATLAS_OFFSETOF(SG_PLAYER, equip_generals), NULL, (_U16)-1, (_U16)2, (_U16)((size_t)(&((DDL::Array<_U32, 2>*)NULL)->_Array)), (_U16)sizeof(_U32), NULL},
		{TYPE_U32|TYPE_ARRAY, "equip_soldiers", 0, ATLAS_OFFSETOF(SG_PLAYER, equip_soldiers), NULL, (_U16)-1, (_U16)3, (_U16)((size_t)(&((DDL::Array<_U32, 3>*)NULL)->_Array)), (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_PLAYER_info = { &_rfl_struct_SG_GENERAL_info, "SG_PLAYER", sizeof(SG_PLAYER), 5, _struct_SG_PLAYER_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_PLAYER>()
	{
		return &_rfl_struct_SG_PLAYER_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_ITEM>(SG_ITEM& Value)
	{
		if(!BufferReader::Read<A_LIVE_OBJECT>(Value)) return false;
		if(!Read<_U32>(Value.item_id)) return false;
		if(!Read<_U32>(Value.count)) return false;
		if(!Read<_U32>(Value.expired_time)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_ITEM>(const SG_ITEM& Value)
	{
		if(!BufferWriter::Write<A_LIVE_OBJECT>(Value)) return false;
		if(!Write<_U32>(Value.item_id)) return false;
		if(!Write<_U32>(Value.count)) return false;
		if(!Write<_U32>(Value.expired_time)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_ITEM_fieldinfo[] =
	{
		{TYPE_U32, "item_id", 0, ATLAS_OFFSETOF(SG_ITEM, item_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "count", 0, ATLAS_OFFSETOF(SG_ITEM, count), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "expired_time", 0, ATLAS_OFFSETOF(SG_ITEM, expired_time), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_ITEM_info = { &_rfl_struct_A_LIVE_OBJECT_info, "SG_ITEM", sizeof(SG_ITEM), 3, _struct_SG_ITEM_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_ITEM>()
	{
		return &_rfl_struct_SG_ITEM_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_EQUIPT_ITEM>(SG_EQUIPT_ITEM& Value)
	{
		if(!BufferReader::Read<SG_ITEM>(Value)) return false;
		if(!Read<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_EQUIPT_ITEM>(const SG_EQUIPT_ITEM& Value)
	{
		if(!BufferWriter::Write<SG_ITEM>(Value)) return false;
		if(!Write<SG_ATTR_MOD_CONFIG>(Value.mod_config)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_EQUIPT_ITEM_fieldinfo[] =
	{
		{TYPE_STRUCT, "mod_config", 0, ATLAS_OFFSETOF(SG_EQUIPT_ITEM, mod_config), &_rfl_struct_SG_ATTR_MOD_CONFIG_info, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(SG_ATTR_MOD_CONFIG), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_EQUIPT_ITEM_info = { &_rfl_struct_SG_ITEM_info, "SG_EQUIPT_ITEM", sizeof(SG_EQUIPT_ITEM), 1, _struct_SG_EQUIPT_ITEM_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_EQUIPT_ITEM>()
	{
		return &_rfl_struct_SG_EQUIPT_ITEM_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_USABLE_ITEM>(SG_USABLE_ITEM& Value)
	{
		if(!BufferReader::Read<SG_ITEM>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_USABLE_ITEM>(const SG_USABLE_ITEM& Value)
	{
		if(!BufferWriter::Write<SG_ITEM>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{
	STRUCT_INFO _rfl_struct_SG_USABLE_ITEM_info = { &_rfl_struct_SG_ITEM_info, "SG_USABLE_ITEM", sizeof(SG_USABLE_ITEM), 0, NULL };
	template<>
	const STRUCT_INFO* GetStruct<SG_USABLE_ITEM>()
	{
		return &_rfl_struct_SG_USABLE_ITEM_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_GEM_ITEM>(SG_GEM_ITEM& Value)
	{
		if(!BufferReader::Read<SG_ITEM>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_GEM_ITEM>(const SG_GEM_ITEM& Value)
	{
		if(!BufferWriter::Write<SG_ITEM>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{
	STRUCT_INFO _rfl_struct_SG_GEM_ITEM_info = { &_rfl_struct_SG_ITEM_info, "SG_GEM_ITEM", sizeof(SG_GEM_ITEM), 0, NULL };
	template<>
	const STRUCT_INFO* GetStruct<SG_GEM_ITEM>()
	{
		return &_rfl_struct_SG_GEM_ITEM_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<SG_SERVER_INFO>(SG_SERVER_INFO& Value)
	{
		if(!Read<_U32>(Value.server_id)) return false;
		if(!ReadString<100>(Value.server_name)) return false;
		if(!Read<_U32>(Value.server_state)) return false;
		if(!ReadString<100>(Value.avatar_nick)) return false;
		if(!Read<_U32>(Value.general_id)) return false;
		if(!Read<_U32>(Value.level)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<SG_SERVER_INFO>(const SG_SERVER_INFO& Value)
	{
		if(!Write<_U32>(Value.server_id)) return false;
		if(!WriteString<100>(Value.server_name)) return false;
		if(!Write<_U32>(Value.server_state)) return false;
		if(!WriteString<100>(Value.avatar_nick)) return false;
		if(!Write<_U32>(Value.general_id)) return false;
		if(!Write<_U32>(Value.level)) return false;
		return true;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _struct_SG_SERVER_INFO_fieldinfo[] =
	{
		{TYPE_U32, "server_id", 0, ATLAS_OFFSETOF(SG_SERVER_INFO, server_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRING, "server_name", 0, ATLAS_OFFSETOF(SG_SERVER_INFO, server_name), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
		{TYPE_U32, "server_state", 0, ATLAS_OFFSETOF(SG_SERVER_INFO, server_state), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_STRING, "avatar_nick", 0, ATLAS_OFFSETOF(SG_SERVER_INFO, avatar_nick), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
		{TYPE_U32, "general_id", 0, ATLAS_OFFSETOF(SG_SERVER_INFO, general_id), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "level", 0, ATLAS_OFFSETOF(SG_SERVER_INFO, level), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_SG_SERVER_INFO_info = { NULL, "SG_SERVER_INFO", sizeof(SG_SERVER_INFO), 6, _struct_SG_SERVER_INFO_fieldinfo };
	template<>
	const STRUCT_INFO* GetStruct<SG_SERVER_INFO>()
	{
		return &_rfl_struct_SG_SERVER_INFO_info;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _class_SGGAME_C2S_fieldinfos[] = 
	{
		// 0 Ping
		// 1 GetServerList
		// 2 EnterServer
		{TYPE_U32, "server_id", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 3 QueryAvatar
		// 4 CreateAvatar
		{TYPE_STRING, "nick", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "general_id", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 5 DeleteAvatar
		// 6 EnterGame
		// 7 LeaveGame
		// 8 QueryPlayer
		// 9 QueryGenerals
		// 10 QuerySoldiers
		// 11 QueryBag
		// 12 EquipItem
		{TYPE_U32, "general_id", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_UUID, "item_uuid", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 13 BeginBattle
		{TYPE_STRING, "name", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 14 EndBattle
		{TYPE_STRING, "name", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "result", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
	};
	static FUNCTION_INFO _class_SGGAME_C2S_funcinfos[] = 
	{
		{"Ping", 0, _class_SGGAME_C2S_fieldinfos+0},
		{"GetServerList", 0, _class_SGGAME_C2S_fieldinfos+0},
		{"EnterServer", 1, _class_SGGAME_C2S_fieldinfos+0},
		{"QueryAvatar", 0, _class_SGGAME_C2S_fieldinfos+1},
		{"CreateAvatar", 2, _class_SGGAME_C2S_fieldinfos+1},
		{"DeleteAvatar", 0, _class_SGGAME_C2S_fieldinfos+3},
		{"EnterGame", 0, _class_SGGAME_C2S_fieldinfos+3},
		{"LeaveGame", 0, _class_SGGAME_C2S_fieldinfos+3},
		{"QueryPlayer", 0, _class_SGGAME_C2S_fieldinfos+3},
		{"QueryGenerals", 0, _class_SGGAME_C2S_fieldinfos+3},
		{"QuerySoldiers", 0, _class_SGGAME_C2S_fieldinfos+3},
		{"QueryBag", 0, _class_SGGAME_C2S_fieldinfos+3},
		{"EquipItem", 2, _class_SGGAME_C2S_fieldinfos+3},
		{"BeginBattle", 1, _class_SGGAME_C2S_fieldinfos+5},
		{"EndBattle", 2, _class_SGGAME_C2S_fieldinfos+6},
	};
	static CLASS_INFO _class_SGGAME_C2S_info = { 0, "SGGAME_C2S", 15, _class_SGGAME_C2S_funcinfos };
	template<>
	const CLASS_INFO* GetClass<SGGAME_C2S>()
	{
		return &_class_SGGAME_C2S_info;
	}
}

namespace DDLReflect
{
	static FIELD_INFO _class_SGGAME_S2C_fieldinfos[] = 
	{
		// 0 Pong
		// 1 GetServerListResult
		{TYPE_STRUCT|TYPE_ARRAY, "infos", 0, 0, &_rfl_struct_SG_SERVER_INFO_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "count", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 2 QueryAvatarFailed
		{TYPE_U32, "code", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 3 QueryAvatarResult
		{TYPE_STRUCT, "player", 0, 0, &_rfl_struct_SG_PLAYER_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 4 CreateAvatarResult
		{TYPE_U32, "code", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 5 QueryPlayerResult
		{TYPE_STRUCT, "player", 0, 0, &_rfl_struct_SG_PLAYER_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 6 QueryGeneralResult
		{TYPE_STRUCT|TYPE_ARRAY, "generals", 0, 0, &_rfl_struct_SG_GENERAL_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "count", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 7 QuerySoldierResult
		{TYPE_STRUCT|TYPE_ARRAY, "soldiers", 0, 0, &_rfl_struct_SG_SOLDIER_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "count", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 8 QueryBagBegin
		// 9 QueryBagEquipt
		{TYPE_STRUCT|TYPE_ARRAY, "items", 0, 0, &_rfl_struct_SG_EQUIPT_ITEM_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "count", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 10 QueryBagUsable
		{TYPE_STRUCT|TYPE_ARRAY, "items", 0, 0, &_rfl_struct_SG_USABLE_ITEM_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "count", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 11 QueryBagGen
		{TYPE_STRUCT|TYPE_ARRAY, "items", 0, 0, &_rfl_struct_SG_GEM_ITEM_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "count", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 12 QueryBagEnd
		// 13 BeginBattleResult
		{TYPE_STRUCT, "PlayerPVE", 0, 0, &_rfl_struct_SG_PLAYER_PVE_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		// 14 EndBattleResult
		{TYPE_U32, "level", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "exp", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "gold", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_STRUCT|TYPE_ARRAY, "drops", 0, 0, &_rfl_struct_SG_DROP_ITEM_CONFIG_info, (_U16)-1,(_U16) -1, 0, 0, NULL},
		{TYPE_U32, "drop_count", 0, 0, NULL, (_U16)-1,(_U16) -1, 0, 0, NULL},
	};
	static FUNCTION_INFO _class_SGGAME_S2C_funcinfos[] = 
	{
		{"Pong", 0, _class_SGGAME_S2C_fieldinfos+0},
		{"GetServerListResult", 2, _class_SGGAME_S2C_fieldinfos+0},
		{"QueryAvatarFailed", 1, _class_SGGAME_S2C_fieldinfos+2},
		{"QueryAvatarResult", 1, _class_SGGAME_S2C_fieldinfos+3},
		{"CreateAvatarResult", 1, _class_SGGAME_S2C_fieldinfos+4},
		{"QueryPlayerResult", 1, _class_SGGAME_S2C_fieldinfos+5},
		{"QueryGeneralResult", 2, _class_SGGAME_S2C_fieldinfos+6},
		{"QuerySoldierResult", 2, _class_SGGAME_S2C_fieldinfos+8},
		{"QueryBagBegin", 0, _class_SGGAME_S2C_fieldinfos+10},
		{"QueryBagEquipt", 2, _class_SGGAME_S2C_fieldinfos+10},
		{"QueryBagUsable", 2, _class_SGGAME_S2C_fieldinfos+12},
		{"QueryBagGen", 2, _class_SGGAME_S2C_fieldinfos+14},
		{"QueryBagEnd", 0, _class_SGGAME_S2C_fieldinfos+16},
		{"BeginBattleResult", 1, _class_SGGAME_S2C_fieldinfos+16},
		{"EndBattleResult", 5, _class_SGGAME_S2C_fieldinfos+17},
	};
	static CLASS_INFO _class_SGGAME_S2C_info = { 0, "SGGAME_S2C", 15, _class_SGGAME_S2C_funcinfos };
	template<>
	const CLASS_INFO* GetClass<SGGAME_S2C>()
	{
		return &_class_SGGAME_S2C_info;
	}
}

