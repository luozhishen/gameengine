////////////////////////////////////////////////
// THIS FILE IS AUTOGENERATED. DO NOT MODIFY! //
////////////////////////////////////////////////

#include <ZionBase.h>
#include "CommonDDL.h"

namespace DDL
{
	template<>
	bool BufferReader::Read<A_CONTENT_OBJECT>(A_CONTENT_OBJECT& Value)
	{
		if(!Read<A_UUID>(Value._uuid)) return false;
		if(!ReadString<100>(Value._name)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<A_CONTENT_OBJECT>(const A_CONTENT_OBJECT& Value)
	{
		if(!Write<A_UUID>(Value._uuid)) return false;
		if(!WriteString<100>(Value._name)) return false;
		return true;
	}
}

namespace DDLReflect
{

	static bool _struct_A_CONTENT_OBJECT_readproc(DDL::BufferReader& buf, void* data)
	{
		return buf.Read<A_CONTENT_OBJECT>(*((A_CONTENT_OBJECT*)data));
	}

	static bool _struct_A_CONTENT_OBJECT_writeproc(DDL::BufferWriter& buf, const void* data)
	{
		return buf.Write<A_CONTENT_OBJECT>(*((const A_CONTENT_OBJECT*)data));
	}

	static FIELD_INFO _struct_A_CONTENT_OBJECT_fieldinfo[] =
	{
		{TYPE_UUID, "_uuid", 0|FLAG_READONLY, (_U16)ZION_OFFSETOF(A_CONTENT_OBJECT, _uuid), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
		{TYPE_STRING, "_name", 0|FLAG_NOTNULL, (_U16)ZION_OFFSETOF(A_CONTENT_OBJECT, _name), NULL, (_U16)100, (_U16)-1, (_U16)0, (_U16)sizeof(DDL::String<100>), NULL},
	};
	STRUCT_INFO _rfl_struct_A_CONTENT_OBJECT_info = { NULL, "A_CONTENT_OBJECT", sizeof(A_CONTENT_OBJECT), 2, _struct_A_CONTENT_OBJECT_fieldinfo, _struct_A_CONTENT_OBJECT_readproc, _struct_A_CONTENT_OBJECT_writeproc };
	template<>
	const STRUCT_INFO* GetStruct<A_CONTENT_OBJECT>()
	{
		return &_rfl_struct_A_CONTENT_OBJECT_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<A_LIVE_OBJECT>(A_LIVE_OBJECT& Value)
	{
		if(!Read<A_UUID>(Value._uuid)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<A_LIVE_OBJECT>(const A_LIVE_OBJECT& Value)
	{
		if(!Write<A_UUID>(Value._uuid)) return false;
		return true;
	}
}

namespace DDLReflect
{

	static bool _struct_A_LIVE_OBJECT_readproc(DDL::BufferReader& buf, void* data)
	{
		return buf.Read<A_LIVE_OBJECT>(*((A_LIVE_OBJECT*)data));
	}

	static bool _struct_A_LIVE_OBJECT_writeproc(DDL::BufferWriter& buf, const void* data)
	{
		return buf.Write<A_LIVE_OBJECT>(*((const A_LIVE_OBJECT*)data));
	}

	static FIELD_INFO _struct_A_LIVE_OBJECT_fieldinfo[] =
	{
		{TYPE_UUID, "_uuid", 0, (_U16)ZION_OFFSETOF(A_LIVE_OBJECT, _uuid), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(A_UUID), NULL},
	};
	STRUCT_INFO _rfl_struct_A_LIVE_OBJECT_info = { NULL, "A_LIVE_OBJECT", sizeof(A_LIVE_OBJECT), 1, _struct_A_LIVE_OBJECT_fieldinfo, _struct_A_LIVE_OBJECT_readproc, _struct_A_LIVE_OBJECT_writeproc };
	template<>
	const STRUCT_INFO* GetStruct<A_LIVE_OBJECT>()
	{
		return &_rfl_struct_A_LIVE_OBJECT_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<A_CONFUSED_NUMBER>(A_CONFUSED_NUMBER& Value)
	{
		if(!Read<_U32>(Value.value)) return false;
		if(!Read<_U32>(Value.mask)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<A_CONFUSED_NUMBER>(const A_CONFUSED_NUMBER& Value)
	{
		if(!Write<_U32>(Value.value)) return false;
		if(!Write<_U32>(Value.mask)) return false;
		return true;
	}
}

namespace DDLReflect
{

	static bool _struct_A_CONFUSED_NUMBER_readproc(DDL::BufferReader& buf, void* data)
	{
		return buf.Read<A_CONFUSED_NUMBER>(*((A_CONFUSED_NUMBER*)data));
	}

	static bool _struct_A_CONFUSED_NUMBER_writeproc(DDL::BufferWriter& buf, const void* data)
	{
		return buf.Write<A_CONFUSED_NUMBER>(*((const A_CONFUSED_NUMBER*)data));
	}

	static FIELD_INFO _struct_A_CONFUSED_NUMBER_fieldinfo[] =
	{
		{TYPE_U32, "value", 0, (_U16)ZION_OFFSETOF(A_CONFUSED_NUMBER, value), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
		{TYPE_U32, "mask", 0, (_U16)ZION_OFFSETOF(A_CONFUSED_NUMBER, mask), NULL, (_U16)-1, (_U16)-1, (_U16)0, (_U16)sizeof(_U32), NULL},
	};
	STRUCT_INFO _rfl_struct_A_CONFUSED_NUMBER_info = { NULL, "A_CONFUSED_NUMBER", sizeof(A_CONFUSED_NUMBER), 2, _struct_A_CONFUSED_NUMBER_fieldinfo, _struct_A_CONFUSED_NUMBER_readproc, _struct_A_CONFUSED_NUMBER_writeproc };
	template<>
	const STRUCT_INFO* GetStruct<A_CONFUSED_NUMBER>()
	{
		return &_rfl_struct_A_CONFUSED_NUMBER_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<A_CONFUSED_INT>(A_CONFUSED_INT& Value)
	{
		if(!BufferReader::Read<A_CONFUSED_NUMBER>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<A_CONFUSED_INT>(const A_CONFUSED_INT& Value)
	{
		if(!BufferWriter::Write<A_CONFUSED_NUMBER>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{

	static bool _struct_A_CONFUSED_INT_readproc(DDL::BufferReader& buf, void* data)
	{
		return buf.Read<A_CONFUSED_INT>(*((A_CONFUSED_INT*)data));
	}

	static bool _struct_A_CONFUSED_INT_writeproc(DDL::BufferWriter& buf, const void* data)
	{
		return buf.Write<A_CONFUSED_INT>(*((const A_CONFUSED_INT*)data));
	}

	STRUCT_INFO _rfl_struct_A_CONFUSED_INT_info = { &_rfl_struct_A_CONFUSED_NUMBER_info, "A_CONFUSED_INT", sizeof(A_CONFUSED_INT), 0, NULL, _struct_A_CONFUSED_INT_readproc, _struct_A_CONFUSED_INT_writeproc };
	template<>
	const STRUCT_INFO* GetStruct<A_CONFUSED_INT>()
	{
		return &_rfl_struct_A_CONFUSED_INT_info;
	}
}

namespace DDL
{
	template<>
	bool BufferReader::Read<A_CONFUSED_FLOAT>(A_CONFUSED_FLOAT& Value)
	{
		if(!BufferReader::Read<A_CONFUSED_NUMBER>(Value)) return false;
		return true;
	}
	template<>
	bool BufferWriter::Write<A_CONFUSED_FLOAT>(const A_CONFUSED_FLOAT& Value)
	{
		if(!BufferWriter::Write<A_CONFUSED_NUMBER>(Value)) return false;
		return true;
	}
}

namespace DDLReflect
{

	static bool _struct_A_CONFUSED_FLOAT_readproc(DDL::BufferReader& buf, void* data)
	{
		return buf.Read<A_CONFUSED_FLOAT>(*((A_CONFUSED_FLOAT*)data));
	}

	static bool _struct_A_CONFUSED_FLOAT_writeproc(DDL::BufferWriter& buf, const void* data)
	{
		return buf.Write<A_CONFUSED_FLOAT>(*((const A_CONFUSED_FLOAT*)data));
	}

	STRUCT_INFO _rfl_struct_A_CONFUSED_FLOAT_info = { &_rfl_struct_A_CONFUSED_NUMBER_info, "A_CONFUSED_FLOAT", sizeof(A_CONFUSED_FLOAT), 0, NULL, _struct_A_CONFUSED_FLOAT_readproc, _struct_A_CONFUSED_FLOAT_writeproc };
	template<>
	const STRUCT_INFO* GetStruct<A_CONFUSED_FLOAT>()
	{
		return &_rfl_struct_A_CONFUSED_FLOAT_info;
	}
}

